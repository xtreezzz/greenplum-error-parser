[
    {
        "log": "elog(ERROR, \"%s: check_foreign_key: \n\t\t\t trigger->tgname);\n\n\t\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\t\n\t\tint\t\t\tfnumber = SPI_fnumber(tupdesc, args[i]);\n\n\t\t\n\t\tif (fnumber <= 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"there is no attribute \\\"%s\\\" in relation \\\"%s\\\"\",\n\t\t\t\t\t\t\targs[i], SPI_getrelname(rel))));\n\n\t\t\n\t\tkvals[i] = SPI_getbinval(trigtuple, tupdesc, fnumber, &isnull);\n\n\t\t\n\t\tif (isnull)\n\t\t{\n\t\t\tSPI_finish();\n\t\t\treturn PointerGetDatum((newtuple == NULL) ? trigtuple : newtuple);\n\t\t}\n\n\t\t\n\t\tif (newtuple != NULL)\n\t\t{\n\t\t\tchar\t   *oldval = SPI_getvalue(trigtuple, tupdesc, fnumber);\n\t\t\tchar\t   *newval;\n\n\t\t\t\n\t\t\tif (oldval == NULL)\n\t\t\t\t\n\t\t\t\telog(ERROR, \"check_foreign_key: SPI_getvalue returned %s\", SPI_result_code_string(SPI_result));\n\t\t\tnewval = SPI_getvalue(newtuple, tupdesc, fnumber);\n\t\t\tif (newval == NULL || strcmp(oldval, newval) != 0)\n\t\t\t\tisequal = false;\n\t\t}\n\n\t\tif (plan->nplans <= 0)\t\n\t\t\targtypes[i] = SPI_gettypeid(tupdesc, fnumber);\n\t}\n\targs_temp = args;\n\tnargs -= nkeys;\n\targs += nkeys;\n\n\t\n\tif (plan->nplans <= 0)\n\t{\n\t\tSPIPlanPtr\tpplan;\n\t\tchar\t\tsql[8192];\n\t\tchar\t  **args2 = args;\n\n\t\tplan->splan = (SPIPlanPtr *) malloc(nrefs * sizeof(SPIPlanPtr));\n\n\t\tfor (r = 0; r < nrefs; r++)\n\t\t{\n\t\t\trelname = args2[0];\n\n\t\t\t\n\t\t\tif (action == 'r')\n\n\t\t\t\tsnprintf(sql, sizeof(sql), \"select 1 from %s where \", relname);\n\n\t\t\t\n\n\t\t\t\n\n\n\t\t\telse if (action == 'c')\n\t\t\t{\n\t\t\t\tif (is_update == 1)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tfn;\n\t\t\t\t\tchar\t   *nv;\n\t\t\t\t\tint\t\t\tk;\n\n\t\t\t\t\tsnprintf(sql, sizeof(sql), \"update %s set \", relname);\n\t\t\t\t\tfor (k = 1; k <= nkeys; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tis_char_type = 0;\n\t\t\t\t\t\tchar\t   *type;\n\n\t\t\t\t\t\tfn = SPI_fnumber(tupdesc, args_temp[k - 1]);\n\t\t\t\t\t\tAssert(fn > 0); \n\t\t\t\t\t\tnv = SPI_getvalue(newtuple, tupdesc, fn);\n\t\t\t\t\t\ttype = SPI_gettype(tupdesc, fn);\n\n\t\t\t\t\t\tif (strcmp(type, \"text\") == 0 ||\n\t\t\t\t\t\t\tstrcmp(type, \"varchar\") == 0 ||\n\t\t\t\t\t\t\tstrcmp(type, \"char\") == 0 ||\n\t\t\t\t\t\t\tstrcmp(type, \"bpchar\") == 0 ||\n\t\t\t\t\t\t\tstrcmp(type, \"date\") == 0 ||\n\t\t\t\t\t\t\tstrcmp(type, \"timestamp\") == 0)\n\t\t\t\t\t\t\tis_char_type = 1;\n\n\t\t\t\t\t\telog(DEBUG4, \"check_foreign_key Debug value %s type %s %d\",\n\t\t\t\t\t\t\t nv, type, is_char_type);\n\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tsnprintf(sql + strlen(sql), sizeof(sql) - strlen(sql),\n\t\t\t\t\t\t\t\t \" %s = %s%s%s %s \",\n\t\t\t\t\t\t\t\t args2[k], (is_char_type > 0) ? \"'\" : \"\",\n\t\t\t\t\t\t\t\t nv, (is_char_type > 0) ? \"'\" : \"\", (k < nkeys) ? \", \" : \"\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(sql, \" where \");\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t\n\t\t\t\t\tsnprintf(sql, sizeof(sql), \"delete from %s where \", relname);\n\n\t\t\t}\n\n\t\t\t\n\t\t\telse if (action == 's')\n\t\t\t{\n\t\t\t\tsnprintf(sql, sizeof(sql), \"update %s set \", relname);\n\t\t\t\tfor (i = 1; i <= nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(sql + strlen(sql), sizeof(sql) - strlen(sql),\n\t\t\t\t\t\t\t \"%s = null%s\",\n\t\t\t\t\t\t\t args2[i], (i < nkeys) ? \", \" : \"\");\n\t\t\t\t}\n\t\t\t\tstrcat(sql, \" where \");\n\t\t\t}\n\n\t\t\t\n\t\t\tfor (i = 1; i <= nkeys; i++)\n\t\t\t{\n\t\t\t\tsnprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), \"%s = $%d %s\",\n\t\t\t\t\t\t args2[i], i, (i < nkeys) ? \"and \" : \"\");\n\t\t\t}\n\n\t\t\t\n\t\t\tpplan = SPI_prepare(sql, nkeys, argtypes);\n\t\t\tif (pplan == NULL)\n\t\t\t\t\n\t\t\t\telog(ERROR, \"check_foreign_key: SPI_prepare returned %s\", SPI_result_code_string(SPI_result));\n\n\t\t\t\n\t\t\tif (SPI_keepplan(pplan))\n\t\t\t\t\n\t\t\t\telog(ERROR, \"check_foreign_key: SPI_keepplan failed\");\n\n\t\t\tplan->splan[r] = pplan;\n\n\t\t\targs2 += nkeys + 1; \n\t\t}\n\t\tplan->nplans = nrefs;\n\n\t\telog(DEBUG4, \"check_foreign_key Debug Query is :  %s \", sql);\n\n\t}\n\n\t\n\tif (newtuple != NULL && isequal)\n\t{\n\t\tSPI_finish();\n\t\treturn PointerGetDatum(newtuple);\n\t}\n\n\t\n\tfor (r = 0; r < nrefs; r++)\n\t{\n\t\t\n\t\tint\t\t\ttcount = (action == 'r') ? 1 : 0;\n\n\t\trelname = args[0];\n\n\t\tsnprintf(ident, sizeof(ident), \"%s$%u\", trigger->tgname, rel->rd_id);\n\t\tplan = find_plan(ident, &FPlans, &nFPlans);\n\t\tret = SPI_execp(plan->splan[r], kvals, NULL, (int64) tcount);\n\t\t\n\n\t\tif (ret < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TRIGGERED_ACTION_EXCEPTION),\n\t\t\t\t\t errmsg(\"SPI_execp returned %d\", ret)));\n\n\t\t\n\t\tif (action == 'r')\n\t\t{\n\t\t\t\n\t\t\tif (SPI_processed > 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_TRIGGERED_ACTION_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\": tuple is referenced in \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttrigger->tgname, relname)));\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\telog(NOTICE, \"%s: \" UINT64_FORMAT \" tuple(s) of %s are %s\",\n\t\t\t\t trigger->tgname, SPI_processed, relname,\n\t\t\t\t (action == 'c') ? \"deleted\" : \"set to null\");\n\n\t\t}\n\t\targs += nkeys + 1;\t\t\n\t}\n\n\tSPI_finish();\n\n\treturn PointerGetDatum((newtuple == NULL) ? trigtuple : newtuple);\n}\n\nstatic EPlan *\nfind_plan(char *ident, EPlan **eplan, int *nplans)\n{\n\tEPlan\t   *newp;\n\tint\t\t\ti;\n\n\tif (*nplans > 0)\n\t{\n\t\tfor (i = 0; i < *nplans; i++)\n\t\t{\n\t\t\tif (strcmp((*eplan)[i].ident, ident) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != *nplans)\n\t\t\treturn (*eplan + i);\n\t\t*eplan = (EPlan *) realloc(*eplan, (i + 1) * sizeof(EPlan));\n\t\tnewp = *eplan + i;\n\t}\n\telse\n\t{\n\t\tnewp = *eplan = (EPlan *) malloc(sizeof(EPlan));\n\t\t(*nplans) = i = 0;\n\t}\n\n\tnewp->ident = strdup(ident);\n\tnewp->nplans = 0;\n\tnewp->splan = NULL;\n\t(*nplans)++;\n\n\treturn newp;\n}\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse elog log",
        "file_path": "contrib/spi/refint.c:288"
    },
    {
        "log": "ereport(ERROR, \\\n\t\t(errcode(ERRCODE_ORA_PACKAGES_\n\t\t errmsg(msg)))\n\n\n\tCUSTOM_EXCEPTION(INVALID_SCHEMA_NAME, \"invalid schema name\")\n\n\n\tCUSTOM_EXCEPTION(INVALID_OBJECT_NAME, \"invalid object name\")\n\n\n\tCUSTOM_EXCEPTION(ISNOT_SIMPLE_SQL_NAME, \"string is not simple SQL name\")\n\n\n\tCUSTOM_EXCEPTION(ISNOT_QUALIFIED_SQL_NAME, \"string is not qualified SQL name\")\n\n\n\nstatic bool check_sql_name(char *cp, int len);\nstatic bool ParseIdentifierString(char *rawstring);\n\n\nbool\nParseIdentifierString(char *rawstring)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\twhile (isspace((unsigned char) *nextp))\n\t\tnextp++;\t\t\t\t\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t\n\n\t\n\tdo\n\t{\n\n\t\tif (*nextp == '\\\"')\n\t\t{\n\t\t\tchar\t   *endp;\n\n\t\t\t\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\\\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t\t\n\n\t\t\t\tif (endp[1] != '\\\"')\n\t\t\t\t\tbreak;\t\t\n\n\t\t\t\t\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\n\t\t\t\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *curname;\n\n\t\t\t\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != '.' &&\n\t\t\t\t   !isspace((unsigned char) *nextp))\n\t\t\t{\n\t\t\t\tif (!isalnum(*nextp) && *nextp != '_')\n\t\t\t\t\treturn false;\n\t\t\t\tnextp++;\n\t\t\t}\n\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t\n\t\t}\n\n\t\twhile (isspace((unsigned char) *nextp))\n\t\t\tnextp++;\t\t\t\n\n\t\tif (*nextp == '.')\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (isspace((unsigned char) *nextp))\n\t\t\t\tnextp++;\t\t\n\t\t\t\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t\n\n\t\t\n\t} while (!done);\n\n\treturn true;\n}\n\n\n\n\n\nDatum\ndbms_assert_enquote_literal(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_DATUM(DirectFunctionCall1(quote_literal, PG_GETARG_DATUM(0)));\n}\n\n\n\n\nDatum\ndbms_assert_enquote_name(PG_FUNCTION_ARGS)\n{\n\tDatum name  = PG_GETARG_DATUM(0);\n\tbool loweralize = PG_GETARG_BOOL(1);\n\tOid collation = PG_GET_COLLATION();\n\n\tname = DirectFunctionCall1(quote_ident, name);\n\n\tif (loweralize)\n\t\tname = DirectFunctionCall1Coll(lower, collation, name);\n\n\tPG_RETURN_DATUM(name);\n}\n\n\n\n\nDatum\ndbms_assert_noop(PG_FUNCTION_ARGS)\n{\n\ttext *str = PG_GETARG_TEXT_P(0);\n\n\tPG_RETURN_TEXT_P(TextPCopy(str));\n}\n\n\n\n\nDatum\ndbms_assert_qualified_sql_name(PG_FUNCTION_ARGS)\n{\n\ttext *qname;\n\n\tif (PG_ARGISNULL(0))\n\t\tISNOT_QUALIFIED_SQL_NAME_EXCEPTION();\n\n\tqname = PG_GETARG_TEXT_P(0);\n\tif (EMPTY_STR(qname))\n\t\tISNOT_QUALIFIED_SQL_NAME_EXCEPTION();\n\n\tif (!ParseIdentifierString(text_to_cstring(qname)))\n\t\tISNOT_QUALIFIED_SQL_NAME_EXCEPTION();\n\n\tPG_RETURN_TEXT_P(qname);\n}\n\n\n\n\nDatum\ndbms_assert_schema_name(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tnamespaceId;\n\tAclResult\taclresult;\n\ttext *sname;\n\tchar *nspname;\n\tList\t*names;\n\n\tif (PG_ARGISNULL(0))\n\t\tINVALID_SCHEMA_NAME_EXCEPTION();\n\n\tsname = PG_GETARG_TEXT_P(0);\n\tif (EMPTY_STR(sname))\n\t\tINVALID_SCHEMA_NAME_EXCEPTION();\n\n\tnspname = text_to_cstring(sname);\n\n\n\n\tnames = stringToQualifiedNameList(nspname, NULL);\n\n\n\n\tnames = stringToQualifiedNameList(nspname);\n\n\n\n\tif (list_length(names) != 1)\n\t\tINVALID_SCHEMA_NAME_EXCEPTION();\n\n\n\n\tnamespaceId = GetSysCacheOid(NAMESPACENAME, Anum_pg_namespace_oid,\n\t\t\t\t\t\t\tCStringGetDatum(strVal(linitial(names))),\n\t\t\t\t\t\t\t0, 0, 0);\n\n\n\n\tnamespaceId = GetSysCacheOid(NAMESPACENAME,\n\t\t\t\t\t\t\tCStringGetDatum(strVal(linitial(names))),\n\t\t\t\t\t\t\t0, 0, 0);\n\n\n\n\n\tif (!OidIsValid(namespaceId))\n\t\tINVALID_SCHEMA_NAME_EXCEPTION();\n\n\n\n\taclresult = object_aclcheck(NamespaceRelationId,namespaceId, GetUserId(),\n\t\t\t\t\t\t\t\tACL_USAGE);\n\n\n\n\taclresult = pg_namespace_aclcheck(namespaceId, GetUserId(), ACL_USAGE);\n\n\n\n\tif (aclresult != ACLCHECK_OK)\n\t\tINVALID_SCHEMA_NAME_EXCEPTION();\n\n\tPG_RETURN_TEXT_P(sname);\n}\n\n\n\n\nstatic bool\ncheck_sql_name(char *cp, int len)\n{\n\tif (*cp == '\"')\n\t{\n\t\tchar\t   *last = cp + len - 1;\n\n\t\t\n\t\tif (len < 3)\n\t\t\treturn false;\n\n\t\t\n\t\tif (*last != '\"')\n\t\t\treturn false;\n\n\t\tcp += 1;\n\n\t\twhile (*cp && cp < last)\n\t\t{\n\t\t\tif (*cp++ == '\"')\n\t\t\t{\n\t\t\t\tif (cp < last)\n\t\t\t\t{\n\t\t\t\t\tif (*cp++ != '\"')\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t\n\t\tfor (; len-- > 0; cp++)\n\t\t\tif (!isalnum(*cp) && *cp != '_')\n\t\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nDatum\ndbms_assert_simple_sql_name(PG_FUNCTION_ARGS)\n{\n\ttext  *sname;\n\tint\t\tlen;\n\tchar *cp;\n\n\tif (PG_ARGISNULL(0))\n\t\tISNOT_SIMPLE_SQL_NAME_EXCEPTION();\n\n\tsname = PG_GETARG_TEXT_P(0);\n\tif (EMPTY_STR(sname))\n\t\tISNOT_SIMPLE_SQL_NAME_EXCEPTION();\n\n\tlen = VARSIZE(sname) - VARHDRSZ;\n\tcp = VARDATA(sname);\n\n\tif (!check_sql_name(cp, len))\n\t\tISNOT_SIMPLE_SQL_NAME_EXCEPTION();\n\n\tPG_RETURN_TEXT_P(sname);\n}\n\n\n\n\nDatum\ndbms_assert_object_name(PG_FUNCTION_ARGS)\n{\n\tList\t*names;\n\ttext\t*str;\n\tchar\t*object_name;\n\tOid \t\tclassId;\n\n\tif (PG_ARGISNULL(0))\n\t\tINVALID_OBJECT_NAME_EXCEPTION();\n\n\tstr = PG_GETARG_TEXT_P(0);\n\tif (EMPTY_STR(str))\n\t\tINVALID_OBJECT_NAME_EXCEPTION();\n\n\tobject_name = text_to_cstring(str);\n\n\n\n\tnames = stringToQualifiedNameList(object_name, NULL);\n\n\n\n\tnames = stringToQualifiedNameList(object_name);\n\n\n\n\tclassId = RangeVarGetRelid(makeRangeVarFromNameList(names), NoLock, true);\n\tif (!OidIsValid(classId))\n\t\tINVALID_OBJECT_NAME_EXCEPTION();\n\n\tPG_RETURN_TEXT_P(str);\n}\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse ereport log",
        "file_path": "gpcontrib/orafce/assert.c:31"
    },
    {
        "log": "ereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"item too long (check \n\t\t\t\t\t\t\t\titemLen, aoInsertDesc->varBlockMaker.maxBufferLen),\n\t\t\t\t\t\t errcontext_appendonly_insert_block_user_limit(aoInsertDesc)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tfinishWriteBlock(aoInsertDesc);\n\t\t\tAssert(aoInsertDesc->nonCompressedData == NULL);\n\t\t\tAssert(!AppendOnlyStorageWrite_IsBufferAllocated(&aoInsertDesc->storageWrite));\n\n\t\t\t\n\t\t\tsetupNextWriteBlock(aoInsertDesc);\n\n\t\t\titemPtr = VarBlockMakerGetNextItemPtr(&aoInsertDesc->varBlockMaker, itemLen);\n\n\t\t\tif (itemPtr == NULL)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (aoInsertDesc->useNoToast)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tisLargeContent = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"item too long (check \n\t\t\t\t\t\t\t\t\titemLen, aoInsertDesc->varBlockMaker.maxBufferLen),\n\t\t\t\t\t\t\t errcontext_appendonly_insert_block_user_limit(aoInsertDesc)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!isLargeContent)\n\t{\n\t\t\n\t\tAssert(itemPtr != NULL);\n\n\t\tif (itemLen > 0)\n\t\t\tmemcpy(itemPtr, tup, itemLen);\n\t}\n\telse\n\t{\n\t\t\n\t\tAssert(itemPtr == NULL);\n\t\tAssert(!need_toast);\n\t\tAssert(instup == tup);\n\n\t\t\n\t\tcancelLastBuffer(aoInsertDesc);\n\t\tAssert(aoInsertDesc->nonCompressedData == NULL);\n\t\tAssert(!AppendOnlyStorageWrite_IsBufferAllocated(&aoInsertDesc->storageWrite));\n\n\t\t\n\t\tAppendOnlyStorageWrite_Content(\n\t\t\t\t\t\t\t\t\t   &aoInsertDesc->storageWrite,\n\t\t\t\t\t\t\t\t\t   (uint8 *) tup,\n\t\t\t\t\t\t\t\t\t   itemLen,\n\t\t\t\t\t\t\t\t\t   AoExecutorBlockKind_SingleRow,\n\t\t\t\t\t\t\t\t\t     1);\n\t\tAssert(aoInsertDesc->nonCompressedData == NULL);\n\t\tAssert(!AppendOnlyStorageWrite_IsBufferAllocated(&aoInsertDesc->storageWrite));\n\n\t\tsetupNextWriteBlock(aoInsertDesc);\n\t}\n\n\taoInsertDesc->insertCount++;\n\taoInsertDesc->lastSequence++;\n\tif (aoInsertDesc->numSequences > 0)\n\t\t(aoInsertDesc->numSequences)--;\n\n\tAssert(aoInsertDesc->numSequences >= 0);\n\n\tAOTupleIdInit(aoTupleId, aoInsertDesc->cur_segno, aoInsertDesc->lastSequence);\n\n\t\n\tif (aoInsertDesc->numSequences == 0)\n\t{\n\t\tint64 firstSequence PG_USED_FOR_ASSERTS_ONLY = GetFastSequences(aoInsertDesc->segrelid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taoInsertDesc->cur_segno,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNUM_FAST_SEQUENCES);\n\n\t\tAssert(firstSequence == aoInsertDesc->lastSequence + 1);\n\t\taoInsertDesc->numSequences = NUM_FAST_SEQUENCES;\n\t}\n\n\telogif(Debug_appendonly_print_insert_tuple, LOG,\n\t\t   \"Append-only insert tuple for table '%s' \"\n\t\t   \"(AOTupleId %s, memtuple length %d, isLargeRow %s, block count \" INT64_FORMAT \")\",\n\t\t   NameStr(aoInsertDesc->aoi_rel->rd_rel->relname),\n\t\t   AOTupleIdToString(aoTupleId),\n\t\t   itemLen,\n\t\t   (isLargeContent ? \"true\" : \"false\"),\n\t\t   aoInsertDesc->bufferCount);\n\n\tif (tup != instup)\n\t\tpfree(tup);\n}\n\n\nvoid\nappendonly_insert_finish(AppendOnlyInsertDesc aoInsertDesc)\n{\n\t\n\tfinishWriteBlock(aoInsertDesc);\n\n\tCloseWritableFileSeg(aoInsertDesc);\n\n\tAppendOnlyBlockDirectory_End_forInsert(&(aoInsertDesc->blockDirectory));\n\n\tAppendOnlyStorageWrite_FinishSession(&aoInsertDesc->storageWrite);\n\n\tUnregisterSnapshot(aoInsertDesc->appendOnlyMetaDataSnapshot);\n\n\tdestroy_memtuple_binding(aoInsertDesc->mt_bind);\n\n\tpfree(aoInsertDesc->title);\n\tpfree(aoInsertDesc);\n}\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse ereport log",
        "file_path": "src/backend/access/appendonly/appendonlyam.c:2760"
    },
    {
        "log": "ereport(ERROR, ...)",
        "severity_level": "ERROR",
        "errmsg_template": null,
        "errmsg_variables": [],
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": null,
        "file_path": "src/backend/access/transam/test/varsup_test.c:74"
    },
    {
        "log": "ereport(WARNING, ...)",
        "severity_level": "WARNING",
        "errmsg_template": null,
        "errmsg_variables": [],
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": null,
        "file_path": "src/backend/access/transam/test/varsup_test.c:138"
    },
    {
        "log": "elog(DEBUG2, \"acl size = %d, \n\t\t ACL_SIZE(acl), ACL_NUM(acl));\n\taip = ACL_DAT(acl);\n\tfor (i = 0; i < ACL_NUM(acl); ++i)\n\t\telog(DEBUG2, \"\tacl[%d]: %s\", i,\n\t\t\t DatumGetCString(DirectFunctionCall1(aclitemout,\n\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(aip + i))));\n}\n\n\n\n\nstatic Acl *\nmerge_acl_with_grant(Acl *old_acl, bool is_grant,\n\t\t\t\t\t bool grant_option, DropBehavior behavior,\n\t\t\t\t\t List *grantees, AclMode privileges,\n\t\t\t\t\t Oid grantorId, Oid ownerId)\n{\n\tunsigned\tmodechg;\n\tListCell   *j;\n\tAcl\t\t   *new_acl;\n\n\tmodechg = is_grant ? ACL_MODECHG_ADD : ACL_MODECHG_DEL;\n\n\n\tdumpacl(old_acl);\n\n\tnew_acl = old_acl;\n\n\tforeach(j, grantees)\n\t{\n\t\tAclItem\t\taclitem;\n\t\tAcl\t\t   *newer_acl;\n\n\t\taclitem.ai_grantee = lfirst_oid(j);\n\n\t\t\n\t\tif (is_grant && grant_option && aclitem.ai_grantee == ACL_ID_PUBLIC)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t errmsg(\"grant options can only be granted to roles\")));\n\n\t\taclitem.ai_grantor = grantorId;\n\n\t\t\n\t\tACLITEM_SET_PRIVS_GOPTIONS(aclitem,\n\t\t\t\t\t\t\t\t   (is_grant || !grant_option) ? privileges : ACL_NO_RIGHTS,\n\t\t\t\t\t\t\t\t   (!is_grant || grant_option) ? privileges : ACL_NO_RIGHTS);\n\n\t\tnewer_acl = aclupdate(new_acl, &aclitem, modechg, ownerId, behavior);\n\n\t\t\n\t\tpfree(new_acl);\n\t\tnew_acl = newer_acl;\n\n\n\t\tdumpacl(new_acl);\n\n\t}\n\n\treturn new_acl;\n}\n\n\nstatic AclMode\nrestrict_and_check_grant(bool is_grant, AclMode avail_goptions, bool all_privs,\n\t\t\t\t\t\t AclMode privileges, Oid objectId, Oid grantorId,\n\t\t\t\t\t\t ObjectType objtype, const char *objname,\n\t\t\t\t\t\t AttrNumber att_number, const char *colname)\n{\n\tAclMode\t\tthis_privileges;\n\tAclMode\t\twhole_mask;\n\n\tswitch (objtype)\n\t{\n\t\tcase OBJECT_COLUMN:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_COLUMN;\n\t\t\tbreak;\n\t\tcase OBJECT_TABLE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_RELATION;\n\t\t\tbreak;\n\t\tcase OBJECT_SEQUENCE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\tbreak;\n\t\tcase OBJECT_DATABASE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_DATABASE;\n\t\t\tbreak;\n\t\tcase OBJECT_FUNCTION:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\tbreak;\n\t\tcase OBJECT_LANGUAGE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_LANGUAGE;\n\t\t\tbreak;\n\t\tcase OBJECT_LARGEOBJECT:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_LARGEOBJECT;\n\t\t\tbreak;\n\t\tcase OBJECT_SCHEMA:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_SCHEMA;\n\t\t\tbreak;\n\t\tcase OBJECT_TABLESPACE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_TABLESPACE;\n\t\t\tbreak;\n\t\tcase OBJECT_FDW:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_FDW;\n\t\t\tbreak;\n\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_FOREIGN_SERVER;\n\t\t\tbreak;\n\t\tcase OBJECT_EVENT_TRIGGER:\n\t\t\telog(ERROR, \"grantable rights not supported for event triggers\");\n\t\t\t\n\t\t\treturn ACL_NO_RIGHTS;\n\t\tcase OBJECT_TYPE:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_TYPE;\n\t\t\tbreak;\n\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\twhole_mask = ACL_ALL_RIGHTS_EXTPROTOCOL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized object type: %d\", objtype);\n\t\t\t\n\t\t\treturn ACL_NO_RIGHTS;\n\t}\n\n\t\n\tif (avail_goptions == ACL_NO_RIGHTS)\n\t{\n\t\tif (pg_aclmask(objtype, objectId, att_number, grantorId,\n\t\t\t\t\t   whole_mask | ACL_GRANT_OPTION_FOR(whole_mask),\n\t\t\t\t\t   ACLMASK_ANY) == ACL_NO_RIGHTS)\n\t\t{\n\t\t\tif (objtype == OBJECT_COLUMN && colname)\n\t\t\t\taclcheck_error_col(ACLCHECK_NO_PRIV, objtype, objname, colname);\n\t\t\telse\n\t\t\t\taclcheck_error(ACLCHECK_NO_PRIV, objtype, objname);\n\t\t}\n\t}\n\n\t\n\tthis_privileges = privileges & ACL_OPTION_TO_PRIVS(avail_goptions);\n\t\n\t\n\tif (Gp_role == GP_ROLE_EXECUTE)\n\t\treturn this_privileges;\n\n\tif (is_grant)\n\t{\n\t\tif (this_privileges == 0)\n\t\t{\n\t\t\tif (objtype == OBJECT_COLUMN && colname)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED),\n\t\t\t\t\t\t errmsg(\"no privileges were granted for column \\\"%s\\\" of relation \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcolname, objname)));\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED),\n\t\t\t\t\t\t errmsg(\"no privileges were granted for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tobjname)));\n\t\t}\n\t\telse if (!all_privs && this_privileges != privileges)\n\t\t{\n\t\t\tif (objtype == OBJECT_COLUMN && colname)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED),\n\t\t\t\t\t\t errmsg(\"not all privileges were granted for column \\\"%s\\\" of relation \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcolname, objname)));\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED),\n\t\t\t\t\t\t errmsg(\"not all privileges were granted for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tobjname)));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this_privileges == 0)\n\t\t{\n\t\t\tif (objtype == OBJECT_COLUMN && colname)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED),\n\t\t\t\t\t\t errmsg(\"no privileges could be revoked for column \\\"%s\\\" of relation \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcolname, objname)));\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED),\n\t\t\t\t\t\t errmsg(\"no privileges could be revoked for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tobjname)));\n\t\t}\n\t\telse if (!all_privs && this_privileges != privileges)\n\t\t{\n\t\t\tif (objtype == OBJECT_COLUMN && colname)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED),\n\t\t\t\t\t\t errmsg(\"not all privileges could be revoked for column \\\"%s\\\" of relation \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcolname, objname)));\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED),\n\t\t\t\t\t\t errmsg(\"not all privileges could be revoked for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tobjname)));\n\t\t}\n\t}\n\n\treturn this_privileges;\n}\n\n\nvoid\nExecuteGrantStmt(GrantStmt *stmt)\n{\n\tInternalGrant istmt;\n\tListCell   *cell;\n\tconst char *errormsg;\n\tAclMode\t\tall_privileges;\n\n\t\n\tistmt.is_grant = stmt->is_grant;\n\tistmt.objtype = stmt->objtype;\n\n\t\n\tswitch (stmt->targtype)\n\t{\n\t\tcase ACL_TARGET_OBJECT:\n\t\t\tistmt.objects = objectNamesToOids(stmt->objtype, stmt->objects);\n\t\t\tbreak;\n\t\tcase ACL_TARGET_ALL_IN_SCHEMA:\n\t\t\tistmt.objects = objectsInSchemaToOids(stmt->objtype, stmt->objects);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized GrantStmt.targtype: %d\",\n\t\t\t\t (int) stmt->targtype);\n\t}\n\n\t\n\t\n\tistmt.col_privs = NIL;\t\t\n\tistmt.grantees = NIL;\t\t\n\tistmt.grant_option = stmt->grant_option;\n\tistmt.behavior = stmt->behavior;\n\n\n\t\n\tforeach(cell, stmt->grantees)\n\t{\n\t\tRoleSpec   *grantee = (RoleSpec *) lfirst(cell);\n\t\tOid\t\t\tgrantee_uid;\n\n\t\tswitch (grantee->roletype)\n\t\t{\n\t\t\tcase ROLESPEC_PUBLIC:\n\t\t\t\tgrantee_uid = ACL_ID_PUBLIC;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgrantee_uid = get_rolespec_oid(grantee, false);\n\t\t\t\tbreak;\n\t\t}\n\t\tistmt.grantees = lappend_oid(istmt.grantees, grantee_uid);\n\t}\n\n\t\n\tswitch (stmt->objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\n\t\t\t\n\t\t\tall_privileges = ACL_ALL_RIGHTS_RELATION | ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for relation\");\n\t\t\tbreak;\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for sequence\");\n\t\t\tbreak;\n\t\tcase OBJECT_DATABASE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_DATABASE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for database\");\n\t\t\tbreak;\n\t\tcase OBJECT_DOMAIN:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_TYPE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for domain\");\n\t\t\tbreak;\n\t\tcase OBJECT_FUNCTION:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for function\");\n\t\t\tbreak;\n\t\tcase OBJECT_LANGUAGE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_LANGUAGE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for language\");\n\t\t\tbreak;\n\t\tcase OBJECT_LARGEOBJECT:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_LARGEOBJECT;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for large object\");\n\t\t\tbreak;\n\t\tcase OBJECT_SCHEMA:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_SCHEMA;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for schema\");\n\t\t\tbreak;\n\t\tcase OBJECT_PROCEDURE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for procedure\");\n\t\t\tbreak;\n\t\tcase OBJECT_ROUTINE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for routine\");\n\t\t\tbreak;\n\t\tcase OBJECT_TABLESPACE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_TABLESPACE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for tablespace\");\n\t\t\tbreak;\n\t\tcase OBJECT_TYPE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_TYPE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for type\");\n\t\t\tbreak;\n\t\tcase OBJECT_FDW:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FDW;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for foreign-data wrapper\");\n\t\t\tbreak;\n\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FOREIGN_SERVER;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for foreign server\");\n\t\t\tbreak;\n\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_EXTPROTOCOL;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for external protocol\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized GrantStmt.objtype: %d\",\n\t\t\t\t (int) stmt->objtype);\n\t\t\t\n\t\t\tall_privileges = ACL_NO_RIGHTS;\n\t\t\terrormsg = NULL;\n\t}\n\n\tif (stmt->privileges == NIL)\n\t{\n\t\tistmt.all_privs = true;\n\n\t\t\n\t\tistmt.privileges = ACL_NO_RIGHTS;\n\t}\n\telse\n\t{\n\t\tistmt.all_privs = false;\n\t\tistmt.privileges = ACL_NO_RIGHTS;\n\n\t\tforeach(cell, stmt->privileges)\n\t\t{\n\t\t\tAccessPriv *privnode = (AccessPriv *) lfirst(cell);\n\t\t\tAclMode\t\tpriv;\n\n\t\t\t\n\t\t\tif (privnode->cols)\n\t\t\t{\n\t\t\t\tif (stmt->objtype != OBJECT_TABLE)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t\t errmsg(\"column privileges are only valid for relations\")));\n\t\t\t\tistmt.col_privs = lappend(istmt.col_privs, privnode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (privnode->priv_name == NULL)\t\n\t\t\t\telog(ERROR, \"AccessPriv node must specify privilege or columns\");\n\t\t\tpriv = string_to_privilege(privnode->priv_name);\n\n\t\t\tif (priv & ~((AclMode) all_privileges))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(errormsg, privilege_to_string(priv))));\n\n\t\t\tistmt.privileges |= priv;\n\t\t}\n\t}\n\n\t\n\trevoked_something = false;\n\n\tExecGrantStmt_oids(&istmt);\n\n\t\n\tif (!revoked_something && !stmt->is_grant && Gp_role == GP_ROLE_DISPATCH)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errcode(ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED),\n\t\t\t\t errmsg(\"no privileges could be revoked\")));\n\t}\n\n\tif (Gp_role == GP_ROLE_DISPATCH)\n\t{\n\t\tGrantStmt *tmpStmt = copyObject(stmt);\n\n\t\tCdbDispatchUtilityStatement((Node *) tmpStmt,\n\t\t\t\t\t\t\t\t\tDF_CANCEL_ON_ERROR|\n\t\t\t\t\t\t\t\t\tDF_WITH_SNAPSHOT|\n\t\t\t\t\t\t\t\t\tDF_NEED_TWO_PHASE,\n\t\t\t\t\t\t\t\t\tNIL,\n\t\t\t\t\t\t\t\t\tNULL);\n\t}\n}\n\n\nstatic void\nExecGrantStmt_oids(InternalGrant *istmt)\n{\n\tswitch (istmt->objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tExecGrant_Relation(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_DATABASE:\n\t\t\tExecGrant_Database(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_DOMAIN:\n\t\tcase OBJECT_TYPE:\n\t\t\tExecGrant_Type(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_FDW:\n\t\t\tExecGrant_Fdw(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\tExecGrant_ForeignServer(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_FUNCTION:\n\t\tcase OBJECT_PROCEDURE:\n\t\tcase OBJECT_ROUTINE:\n\t\t\tExecGrant_Function(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_LANGUAGE:\n\t\t\tExecGrant_Language(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_LARGEOBJECT:\n\t\t\tExecGrant_Largeobject(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_SCHEMA:\n\t\t\tExecGrant_Namespace(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_TABLESPACE:\n\t\t\tExecGrant_Tablespace(istmt);\n\t\t\tbreak;\n\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\tExecGrant_ExtProtocol(istmt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized GrantStmt.objtype: %d\",\n\t\t\t\t (int) istmt->objtype);\n\t}\n\n\t\n\tif (EventTriggerSupportsObjectType(istmt->objtype))\n\t\tEventTriggerCollectGrant(istmt);\n}\n\n\nstatic List *\nobjectNamesToOids(ObjectType objtype, List *objnames)\n{\n\tList\t   *objects = NIL;\n\tListCell   *cell;\n\n\tAssert(objnames != NIL);\n\n\tswitch (objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tRangeVar   *relvar = (RangeVar *) lfirst(cell);\n\t\t\t\tOid\t\t\trelOid;\n\t\t\t\tbool\t\trelOidAddedToObjects = false;\n\n\t\t\t\trelOid = RangeVarGetRelid(relvar, NoLock, false);\n\t\t\t\t\n\t\t\t\tif (objtype == OBJECT_TABLE && relvar->inh)\n\t\t\t\t{\n\t\t\t\t\tHeapTuple\ttp;\n\n\t\t\t\t\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relOid));\n\t\t\t\t\tif (HeapTupleIsValid(tp))\n\t\t\t\t\t{\n\t\t\t\t\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\t\t\t\t\tif (reltup->relkind == RELKIND_PARTITIONED_TABLE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList *all_inheritors = find_all_inheritors(relOid, NoLock, NULL);\n\t\t\t\t\t\t\tobjects = list_concat(objects, all_inheritors);\n\t\t\t\t\t\t\trelOidAddedToObjects = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tReleaseSysCache(tp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!relOidAddedToObjects)\n\t\t\t\t\tobjects = lappend_oid(objects, relOid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_DATABASE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *dbname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\tdbid;\n\n\t\t\t\tdbid = get_database_oid(dbname, false);\n\t\t\t\tobjects = lappend_oid(objects, dbid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_DOMAIN:\n\t\tcase OBJECT_TYPE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tList\t   *typname = (List *) lfirst(cell);\n\t\t\t\tOid\t\t\toid;\n\n\t\t\t\toid = typenameTypeId(NULL, makeTypeNameFromNameList(typname));\n\t\t\t\tobjects = lappend_oid(objects, oid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_FUNCTION:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tObjectWithArgs *func = (ObjectWithArgs *) lfirst(cell);\n\t\t\t\tOid\t\t\tfuncid;\n\n\t\t\t\tfuncid = LookupFuncWithArgs(OBJECT_FUNCTION, func, false);\n\t\t\t\tobjects = lappend_oid(objects, funcid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_LANGUAGE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *langname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\toid;\n\n\t\t\t\toid = get_language_oid(langname, false);\n\t\t\t\tobjects = lappend_oid(objects, oid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_LARGEOBJECT:\n\t\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"large objects are not supported\")));\n\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tOid\t\t\tlobjOid = oidparse(lfirst(cell));\n\n\t\t\t\tif (!LargeObjectExists(lobjOid))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t\t\t errmsg(\"large object %u does not exist\",\n\t\t\t\t\t\t\t\t\tlobjOid)));\n\n\t\t\t\tobjects = lappend_oid(objects, lobjOid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_SCHEMA:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *nspname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\toid;\n\n\t\t\t\toid = get_namespace_oid(nspname, false);\n\t\t\t\tobjects = lappend_oid(objects, oid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_PROCEDURE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tObjectWithArgs *func = (ObjectWithArgs *) lfirst(cell);\n\t\t\t\tOid\t\t\tprocid;\n\n\t\t\t\tprocid = LookupFuncWithArgs(OBJECT_PROCEDURE, func, false);\n\t\t\t\tobjects = lappend_oid(objects, procid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_ROUTINE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tObjectWithArgs *func = (ObjectWithArgs *) lfirst(cell);\n\t\t\t\tOid\t\t\troutid;\n\n\t\t\t\troutid = LookupFuncWithArgs(OBJECT_ROUTINE, func, false);\n\t\t\t\tobjects = lappend_oid(objects, routid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_TABLESPACE:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *spcname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\tspcoid;\n\n\t\t\t\tspcoid = get_tablespace_oid(spcname, false);\n\t\t\t\tobjects = lappend_oid(objects, spcoid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_FDW:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *fdwname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\tfdwid = get_foreign_data_wrapper_oid(fdwname, false);\n\n\t\t\t\tobjects = lappend_oid(objects, fdwid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *srvname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\tsrvid = get_foreign_server_oid(srvname, false);\n\n\t\t\t\tobjects = lappend_oid(objects, srvid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\tforeach(cell, objnames)\n\t\t\t{\n\t\t\t\tchar\t   *ptcname = strVal(lfirst(cell));\n\t\t\t\tOid\t\t\tptcid = get_extprotocol_oid(ptcname, false);\n\n\t\t\t\tobjects = lappend_oid(objects, ptcid);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized GrantStmt.objtype: %d\",\n\t\t\t\t (int) objtype);\n\t}\n\n\treturn objects;\n}\n\n\nstatic List *\nobjectsInSchemaToOids(ObjectType objtype, List *nspnames)\n{\n\tList\t   *objects = NIL;\n\tListCell   *cell;\n\n\tforeach(cell, nspnames)\n\t{\n\t\tchar\t   *nspname = strVal(lfirst(cell));\n\t\tOid\t\t\tnamespaceId;\n\t\tList\t   *objs;\n\n\t\tnamespaceId = LookupExplicitNamespace(nspname, false);\n\n\t\tswitch (objtype)\n\t\t{\n\t\t\tcase OBJECT_TABLE:\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_RELATION);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_VIEW);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_MATVIEW);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_FOREIGN_TABLE);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_PARTITIONED_TABLE);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tbreak;\n\t\t\tcase OBJECT_SEQUENCE:\n\t\t\t\tobjs = getRelationsInNamespace(namespaceId, RELKIND_SEQUENCE);\n\t\t\t\tobjects = list_concat(objects, objs);\n\t\t\t\tbreak;\n\t\t\tcase OBJECT_FUNCTION:\n\t\t\tcase OBJECT_PROCEDURE:\n\t\t\tcase OBJECT_ROUTINE:\n\t\t\t\t{\n\t\t\t\t\tScanKeyData key[2];\n\t\t\t\t\tint\t\t\tkeycount;\n\t\t\t\t\tRelation\trel;\n\t\t\t\t\tTableScanDesc scan;\n\t\t\t\t\tHeapTuple\ttuple;\n\n\t\t\t\t\tkeycount = 0;\n\t\t\t\t\tScanKeyInit(&key[keycount++],\n\t\t\t\t\t\t\t\tAnum_pg_proc_pronamespace,\n\t\t\t\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(namespaceId));\n\n\t\t\t\t\tif (objtype == OBJECT_FUNCTION)\n\t\t\t\t\t\t\n\t\t\t\t\t\tScanKeyInit(&key[keycount++],\n\t\t\t\t\t\t\t\t\tAnum_pg_proc_prokind,\n\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber, F_CHARNE,\n\t\t\t\t\t\t\t\t\tCharGetDatum(PROKIND_PROCEDURE));\n\t\t\t\t\telse if (objtype == OBJECT_PROCEDURE)\n\t\t\t\t\t\tScanKeyInit(&key[keycount++],\n\t\t\t\t\t\t\t\t\tAnum_pg_proc_prokind,\n\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\t\t\t\t\t\tCharGetDatum(PROKIND_PROCEDURE));\n\n\t\t\t\t\trel = table_open(ProcedureRelationId, AccessShareLock);\n\t\t\t\t\tscan = table_beginscan_catalog(rel, keycount, key);\n\n\t\t\t\t\twhile ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tOid\t\t\toid = ((Form_pg_proc) GETSTRUCT(tuple))->oid;\n\n\t\t\t\t\t\tobjects = lappend_oid(objects, oid);\n\t\t\t\t\t}\n\n\t\t\t\t\ttable_endscan(scan);\n\t\t\t\t\ttable_close(rel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\telog(ERROR, \"unrecognized GrantStmt.objtype: %d\",\n\t\t\t\t\t (int) objtype);\n\t\t}\n\t}\n\n\treturn objects;\n}\n\n\nstatic List *\ngetRelationsInNamespace(Oid namespaceId, char relkind)\n{\n\tList\t   *relations = NIL;\n\tScanKeyData key[2];\n\tRelation\trel;\n\tTableScanDesc scan;\n\tHeapTuple\ttuple;\n\n\tScanKeyInit(&key[0],\n\t\t\t\tAnum_pg_class_relnamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(namespaceId));\n\tScanKeyInit(&key[1],\n\t\t\t\tAnum_pg_class_relkind,\n\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\tCharGetDatum(relkind));\n\n\trel = table_open(RelationRelationId, AccessShareLock);\n\tscan = table_beginscan_catalog(rel, 2, key);\n\n\twhile ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)\n\t{\n\t\tOid\t\t\toid = ((Form_pg_class) GETSTRUCT(tuple))->oid;\n\n\t\trelations = lappend_oid(relations, oid);\n\t}\n\n\ttable_endscan(scan);\n\ttable_close(rel, AccessShareLock);\n\n\treturn relations;\n}\n\n\n\nvoid\nExecAlterDefaultPrivilegesStmt(ParseState *pstate, AlterDefaultPrivilegesStmt *stmt)\n{\n\tGrantStmt  *action = stmt->action;\n\tInternalDefaultACL iacls;\n\tListCell   *cell;\n\tList\t   *rolespecs = NIL;\n\tList\t   *nspnames = NIL;\n\tDefElem    *drolespecs = NULL;\n\tDefElem    *dnspnames = NULL;\n\tAclMode\t\tall_privileges;\n\tconst char *errormsg;\n\n\t\n\tforeach(cell, stmt->options)\n\t{\n\t\tDefElem    *defel = (DefElem *) lfirst(cell);\n\n\t\tif (strcmp(defel->defname, \"schemas\") == 0)\n\t\t{\n\t\t\tif (dnspnames)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"conflicting or redundant options\"),\n\t\t\t\t\t\t parser_errposition(pstate, defel->location)));\n\t\t\tdnspnames = defel;\n\t\t}\n\t\telse if (strcmp(defel->defname, \"roles\") == 0)\n\t\t{\n\t\t\tif (drolespecs)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"conflicting or redundant options\"),\n\t\t\t\t\t\t parser_errposition(pstate, defel->location)));\n\t\t\tdrolespecs = defel;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"option \\\"%s\\\" not recognized\", defel->defname);\n\t}\n\n\tif (dnspnames)\n\t\tnspnames = (List *) dnspnames->arg;\n\tif (drolespecs)\n\t\trolespecs = (List *) drolespecs->arg;\n\n\t\n\t\n\t\n\tiacls.is_grant = action->is_grant;\n\tiacls.objtype = action->objtype;\n\t\n\t\n\tiacls.grantees = NIL;\t\t\n\tiacls.grant_option = action->grant_option;\n\tiacls.behavior = action->behavior;\n\n\t\n\tforeach(cell, action->grantees)\n\t{\n\t\tRoleSpec   *grantee = (RoleSpec *) lfirst(cell);\n\t\tOid\t\t\tgrantee_uid;\n\n\t\tswitch (grantee->roletype)\n\t\t{\n\t\t\tcase ROLESPEC_PUBLIC:\n\t\t\t\tgrantee_uid = ACL_ID_PUBLIC;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgrantee_uid = get_rolespec_oid(grantee, false);\n\t\t\t\tbreak;\n\t\t}\n\t\tiacls.grantees = lappend_oid(iacls.grantees, grantee_uid);\n\t}\n\n\t\n\tswitch (action->objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_RELATION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for relation\");\n\t\t\tbreak;\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for sequence\");\n\t\t\tbreak;\n\t\tcase OBJECT_FUNCTION:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for function\");\n\t\t\tbreak;\n\t\tcase OBJECT_PROCEDURE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for procedure\");\n\t\t\tbreak;\n\t\tcase OBJECT_ROUTINE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for routine\");\n\t\t\tbreak;\n\t\tcase OBJECT_TYPE:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_TYPE;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for type\");\n\t\t\tbreak;\n\t\tcase OBJECT_SCHEMA:\n\t\t\tall_privileges = ACL_ALL_RIGHTS_SCHEMA;\n\t\t\terrormsg = gettext_noop(\"invalid privilege type %s for schema\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized GrantStmt.objtype: %d\",\n\t\t\t\t (int) action->objtype);\n\t\t\t\n\t\t\tall_privileges = ACL_NO_RIGHTS;\n\t\t\terrormsg = NULL;\n\t}\n\n\tif (action->privileges == NIL)\n\t{\n\t\tiacls.all_privs = true;\n\n\t\t\n\t\tiacls.privileges = ACL_NO_RIGHTS;\n\t}\n\telse\n\t{\n\t\tiacls.all_privs = false;\n\t\tiacls.privileges = ACL_NO_RIGHTS;\n\n\t\tforeach(cell, action->privileges)\n\t\t{\n\t\t\tAccessPriv *privnode = (AccessPriv *) lfirst(cell);\n\t\t\tAclMode\t\tpriv;\n\n\t\t\tif (privnode->cols)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(\"default privileges cannot be set for columns\")));\n\n\t\t\tif (privnode->priv_name == NULL)\t\n\t\t\t\telog(ERROR, \"AccessPriv node must specify privilege\");\n\t\t\tpriv = string_to_privilege(privnode->priv_name);\n\n\t\t\tif (priv & ~((AclMode) all_privileges))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(errormsg, privilege_to_string(priv))));\n\n\t\t\tiacls.privileges |= priv;\n\t\t}\n\t}\n\n\tif (rolespecs == NIL)\n\t{\n\t\t\n\t\tiacls.roleid = GetUserId();\n\n\t\tSetDefaultACLsInSchemas(&iacls, nspnames);\n\t}\n\telse\n\t{\n\t\t\n\t\tListCell   *rolecell;\n\n\t\tforeach(rolecell, rolespecs)\n\t\t{\n\t\t\tRoleSpec   *rolespec = lfirst(rolecell);\n\n\t\t\tiacls.roleid = get_rolespec_oid(rolespec, false);\n\n\t\t\t\n\t\t\tcheck_is_member_of_role(GetUserId(), iacls.roleid);\n\n\t\t\tSetDefaultACLsInSchemas(&iacls, nspnames);\n\t\t}\n\t}\n\n\tif (Gp_role == GP_ROLE_DISPATCH)\n\t{\n\t\tCdbDispatchUtilityStatement((Node *) stmt,\n\t\t\t\t\t\t\t\t\tDF_CANCEL_ON_ERROR|\n\t\t\t\t\t\t\t\t\tDF_WITH_SNAPSHOT|\n\t\t\t\t\t\t\t\t\tDF_NEED_TWO_PHASE,\n\t\t\t\t\t\t\t\t\tGetAssignedOidsForDispatch(),\n\t\t\t\t\t\t\t\t\tNULL);\n\t}\n}\n\n\nstatic void\nSetDefaultACLsInSchemas(InternalDefaultACL *iacls, List *nspnames)\n{\n\tif (nspnames == NIL)\n\t{\n\t\t\n\t\tiacls->nspid = InvalidOid;\n\n\t\tSetDefaultACL(iacls);\n\t}\n\telse\n\t{\n\t\t\n\t\tListCell   *nspcell;\n\n\t\tforeach(nspcell, nspnames)\n\t\t{\n\t\t\tchar\t   *nspname = strVal(lfirst(nspcell));\n\n\t\t\tiacls->nspid = get_namespace_oid(nspname, false);\n\n\t\t\t\n\n\t\t\tSetDefaultACL(iacls);\n\t\t}\n\t}\n}\n\n\n\nstatic void\nSetDefaultACL(InternalDefaultACL *iacls)\n{\n\tAclMode\t\tthis_privileges = iacls->privileges;\n\tchar\t\tobjtype;\n\tRelation\trel;\n\tHeapTuple\ttuple;\n\tbool\t\tisNew;\n\tAcl\t\t   *def_acl;\n\tAcl\t\t   *old_acl;\n\tAcl\t\t   *new_acl;\n\tHeapTuple\tnewtuple;\n\tDatum\t\tvalues[Natts_pg_default_acl];\n\tbool\t\tnulls[Natts_pg_default_acl];\n\tbool\t\treplaces[Natts_pg_default_acl];\n\tint\t\t\tnoldmembers;\n\tint\t\t\tnnewmembers;\n\tOid\t\t   *oldmembers;\n\tOid\t\t   *newmembers;\n\n\trel = table_open(DefaultAclRelationId, RowExclusiveLock);\n\n\t\n\tif (!OidIsValid(iacls->nspid))\n\t\tdef_acl = acldefault(iacls->objtype, iacls->roleid);\n\telse\n\t\tdef_acl = make_empty_acl();\n\n\t\n\tswitch (iacls->objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\t\t\tobjtype = DEFACLOBJ_RELATION;\n\t\t\tif (iacls->all_privs && this_privileges == ACL_NO_RIGHTS)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_RELATION;\n\t\t\tbreak;\n\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tobjtype = DEFACLOBJ_SEQUENCE;\n\t\t\tif (iacls->all_privs && this_privileges == ACL_NO_RIGHTS)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\tbreak;\n\n\t\tcase OBJECT_FUNCTION:\n\t\t\tobjtype = DEFACLOBJ_FUNCTION;\n\t\t\tif (iacls->all_privs && this_privileges == ACL_NO_RIGHTS)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_FUNCTION;\n\t\t\tbreak;\n\n\t\tcase OBJECT_TYPE:\n\t\t\tobjtype = DEFACLOBJ_TYPE;\n\t\t\tif (iacls->all_privs && this_privileges == ACL_NO_RIGHTS)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_TYPE;\n\t\t\tbreak;\n\n\t\tcase OBJECT_SCHEMA:\n\t\t\tif (OidIsValid(iacls->nspid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(\"cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS\")));\n\t\t\tobjtype = DEFACLOBJ_NAMESPACE;\n\t\t\tif (iacls->all_privs && this_privileges == ACL_NO_RIGHTS)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_SCHEMA;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized objtype: %d\",\n\t\t\t\t (int) iacls->objtype);\n\t\t\tobjtype = 0;\t\t\n\t\t\tbreak;\n\t}\n\n\t\n\ttuple = SearchSysCache3(DEFACLROLENSPOBJ,\n\t\t\t\t\t\t\tObjectIdGetDatum(iacls->roleid),\n\t\t\t\t\t\t\tObjectIdGetDatum(iacls->nspid),\n\t\t\t\t\t\t\tCharGetDatum(objtype));\n\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\n\t\taclDatum = SysCacheGetAttr(DEFACLROLENSPOBJ, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_default_acl_defaclacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (!isNull)\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\telse\n\t\t\told_acl = NULL;\t\t\n\t\tisNew = false;\n\t}\n\telse\n\t{\n\t\told_acl = NULL;\n\t\tisNew = true;\n\t}\n\n\tif (old_acl != NULL)\n\t{\n\t\t\n\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t}\n\telse\n\t{\n\t\t\n\t\told_acl = aclcopy(def_acl);\n\t\t\n\t\tnoldmembers = 0;\n\t\toldmembers = NULL;\n\t}\n\n\t\n\tnew_acl = merge_acl_with_grant(old_acl,\n\t\t\t\t\t\t\t\t   iacls->is_grant,\n\t\t\t\t\t\t\t\t   iacls->grant_option,\n\t\t\t\t\t\t\t\t   iacls->behavior,\n\t\t\t\t\t\t\t\t   iacls->grantees,\n\t\t\t\t\t\t\t\t   this_privileges,\n\t\t\t\t\t\t\t\t   iacls->roleid,\n\t\t\t\t\t\t\t\t   iacls->roleid);\n\n\t\n\taclitemsort(new_acl);\n\taclitemsort(def_acl);\n\tif (aclequal(new_acl, def_acl))\n\t{\n\t\t\n\t\tif (!isNew)\n\t\t{\n\t\t\tObjectAddress myself;\n\n\t\t\t\n\t\t\tmyself.classId = DefaultAclRelationId;\n\t\t\tmyself.objectId = ((Form_pg_default_acl) GETSTRUCT(tuple))->oid;\n\t\t\tmyself.objectSubId = 0;\n\n\t\t\tperformDeletion(&myself, DROP_RESTRICT, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tOid\t\t\tdefAclOid;\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\tif (isNew)\n\t\t{\n\t\t\t\n\t\t\tdefAclOid = GetNewOidForDefaultAcl(rel, DefaultAclOidIndexId,\n\t\t\t\t\t\t\t\t\t\t\t   Anum_pg_default_acl_oid,\n\t\t\t\t\t\t\t\t\t\t\t   iacls->roleid, iacls->nspid, objtype);\n\t\t\tvalues[Anum_pg_default_acl_oid - 1] = ObjectIdGetDatum(defAclOid);\n\t\t\tvalues[Anum_pg_default_acl_defaclrole - 1] = ObjectIdGetDatum(iacls->roleid);\n\t\t\tvalues[Anum_pg_default_acl_defaclnamespace - 1] = ObjectIdGetDatum(iacls->nspid);\n\t\t\tvalues[Anum_pg_default_acl_defaclobjtype - 1] = CharGetDatum(objtype);\n\t\t\tvalues[Anum_pg_default_acl_defaclacl - 1] = PointerGetDatum(new_acl);\n\n\t\t\tnewtuple = heap_form_tuple(RelationGetDescr(rel), values, nulls);\n\t\t\tCatalogTupleInsert(rel, newtuple);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdefAclOid = ((Form_pg_default_acl) GETSTRUCT(tuple))->oid;\n\n\t\t\t\n\t\t\tvalues[Anum_pg_default_acl_defaclacl - 1] = PointerGetDatum(new_acl);\n\t\t\treplaces[Anum_pg_default_acl_defaclacl - 1] = true;\n\n\t\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(rel),\n\t\t\t\t\t\t\t\t\t\t values, nulls, replaces);\n\t\t\tCatalogTupleUpdate(rel, &newtuple->t_self, newtuple);\n\t\t}\n\n\t\t\n\t\tif (isNew)\n\t\t{\n\t\t\t\n\t\t\trecordDependencyOnOwner(DefaultAclRelationId, defAclOid,\n\t\t\t\t\t\t\t\t\tiacls->roleid);\n\n\t\t\t\n\t\t\tif (OidIsValid(iacls->nspid))\n\t\t\t{\n\t\t\t\tObjectAddress myself,\n\t\t\t\t\t\t\treferenced;\n\n\t\t\t\tmyself.classId = DefaultAclRelationId;\n\t\t\t\tmyself.objectId = defAclOid;\n\t\t\t\tmyself.objectSubId = 0;\n\n\t\t\t\treferenced.classId = NamespaceRelationId;\n\t\t\t\treferenced.objectId = iacls->nspid;\n\t\t\t\treferenced.objectSubId = 0;\n\n\t\t\t\trecordDependencyOn(&myself, &referenced, DEPENDENCY_AUTO);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\tupdateAclDependencies(DefaultAclRelationId,\n\t\t\t\t\t\t\t  defAclOid, 0,\n\t\t\t\t\t\t\t  iacls->roleid,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tif (isNew)\n\t\t\tInvokeObjectPostCreateHook(DefaultAclRelationId, defAclOid, 0);\n\t\telse\n\t\t\tInvokeObjectPostAlterHook(DefaultAclRelationId, defAclOid, 0);\n\t}\n\n\tif (HeapTupleIsValid(tuple))\n\t\tReleaseSysCache(tuple);\n\n\ttable_close(rel, RowExclusiveLock);\n\n\t\n\tCommandCounterIncrement();\n}\n\n\n\nvoid\nRemoveRoleFromObjectACL(Oid roleid, Oid classid, Oid objid)\n{\n\tif (classid == DefaultAclRelationId)\n\t{\n\t\tInternalDefaultACL iacls;\n\t\tForm_pg_default_acl pg_default_acl_tuple;\n\t\tRelation\trel;\n\t\tScanKeyData skey[1];\n\t\tSysScanDesc scan;\n\t\tHeapTuple\ttuple;\n\n\t\t\n\t\trel = table_open(DefaultAclRelationId, AccessShareLock);\n\n\t\tScanKeyInit(&skey[0],\n\t\t\t\t\tAnum_pg_default_acl_oid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(objid));\n\n\t\tscan = systable_beginscan(rel, DefaultAclOidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\t\ttuple = systable_getnext(scan);\n\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"could not find tuple for default ACL %u\", objid);\n\n\t\tpg_default_acl_tuple = (Form_pg_default_acl) GETSTRUCT(tuple);\n\n\t\tiacls.roleid = pg_default_acl_tuple->defaclrole;\n\t\tiacls.nspid = pg_default_acl_tuple->defaclnamespace;\n\n\t\tswitch (pg_default_acl_tuple->defaclobjtype)\n\t\t{\n\t\t\tcase DEFACLOBJ_RELATION:\n\t\t\t\tiacls.objtype = OBJECT_TABLE;\n\t\t\t\tbreak;\n\t\t\tcase DEFACLOBJ_SEQUENCE:\n\t\t\t\tiacls.objtype = OBJECT_SEQUENCE;\n\t\t\t\tbreak;\n\t\t\tcase DEFACLOBJ_FUNCTION:\n\t\t\t\tiacls.objtype = OBJECT_FUNCTION;\n\t\t\t\tbreak;\n\t\t\tcase DEFACLOBJ_TYPE:\n\t\t\t\tiacls.objtype = OBJECT_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase DEFACLOBJ_NAMESPACE:\n\t\t\t\tiacls.objtype = OBJECT_SCHEMA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\telog(ERROR, \"unexpected default ACL type: %d\",\n\t\t\t\t\t (int) pg_default_acl_tuple->defaclobjtype);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\t\ttable_close(rel, AccessShareLock);\n\n\t\tiacls.is_grant = false;\n\t\tiacls.all_privs = true;\n\t\tiacls.privileges = ACL_NO_RIGHTS;\n\t\tiacls.grantees = list_make1_oid(roleid);\n\t\tiacls.grant_option = false;\n\t\tiacls.behavior = DROP_CASCADE;\n\n\t\t\n\t\tSetDefaultACL(&iacls);\n\t}\n\telse\n\t{\n\t\tInternalGrant istmt;\n\n\t\tswitch (classid)\n\t\t{\n\t\t\tcase RelationRelationId:\n\t\t\t\t\n\t\t\t\tistmt.objtype = OBJECT_TABLE;\n\t\t\t\tbreak;\n\t\t\tcase DatabaseRelationId:\n\t\t\t\tistmt.objtype = OBJECT_DATABASE;\n\t\t\t\tbreak;\n\t\t\tcase TypeRelationId:\n\t\t\t\tistmt.objtype = OBJECT_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ProcedureRelationId:\n\t\t\t\tistmt.objtype = OBJECT_ROUTINE;\n\t\t\t\tbreak;\n\t\t\tcase LanguageRelationId:\n\t\t\t\tistmt.objtype = OBJECT_LANGUAGE;\n\t\t\t\tbreak;\n\t\t\tcase LargeObjectRelationId:\n\t\t\t\tistmt.objtype = OBJECT_LARGEOBJECT;\n\t\t\t\tbreak;\n\t\t\tcase NamespaceRelationId:\n\t\t\t\tistmt.objtype = OBJECT_SCHEMA;\n\t\t\t\tbreak;\n\t\t\tcase TableSpaceRelationId:\n\t\t\t\tistmt.objtype = OBJECT_TABLESPACE;\n\t\t\t\tbreak;\n\t\t\tcase ForeignServerRelationId:\n\t\t\t\tistmt.objtype = OBJECT_FOREIGN_SERVER;\n\t\t\t\tbreak;\n\t\t\tcase ForeignDataWrapperRelationId:\n\t\t\t\tistmt.objtype = OBJECT_FDW;\n\t\t\t\tbreak;\n\t\t\tcase ExtprotocolRelationId:\n\t\t\t\tistmt.objtype = OBJECT_EXTPROTOCOL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected object class %u\", classid);\n\t\t\t\tbreak;\n\t\t}\n\t\tistmt.is_grant = false;\n\t\tistmt.objects = list_make1_oid(objid);\n\t\tistmt.all_privs = true;\n\t\tistmt.privileges = ACL_NO_RIGHTS;\n\t\tistmt.col_privs = NIL;\n\t\tistmt.grantees = list_make1_oid(roleid);\n\t\tistmt.grant_option = false;\n\t\tistmt.behavior = DROP_CASCADE;\n\n\t\tExecGrantStmt_oids(&istmt);\n\t}\n}\n\n\n\nvoid\nRemoveDefaultACLById(Oid defaclOid)\n{\n\tRelation\trel;\n\tScanKeyData skey[1];\n\tSysScanDesc scan;\n\tHeapTuple\ttuple;\n\n\trel = table_open(DefaultAclRelationId, RowExclusiveLock);\n\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_default_acl_oid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(defaclOid));\n\n\tscan = systable_beginscan(rel, DefaultAclOidIndexId, true,\n\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\ttuple = systable_getnext(scan);\n\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"could not find tuple for default ACL %u\", defaclOid);\n\n\tCatalogTupleDelete(rel, &tuple->t_self);\n\n\tsystable_endscan(scan);\n\ttable_close(rel, RowExclusiveLock);\n}\n\n\n\nstatic void\nexpand_col_privileges(List *colnames, Oid table_oid,\n\t\t\t\t\t  AclMode this_privileges,\n\t\t\t\t\t  AclMode *col_privileges,\n\t\t\t\t\t  int num_col_privileges)\n{\n\tListCell   *cell;\n\n\tforeach(cell, colnames)\n\t{\n\t\tchar\t   *colname = strVal(lfirst(cell));\n\t\tAttrNumber\tattnum;\n\n\t\tattnum = get_attnum(table_oid, colname);\n\t\tif (attnum == InvalidAttrNumber)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" of relation \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\tcolname, get_rel_name(table_oid))));\n\t\tattnum -= FirstLowInvalidHeapAttributeNumber;\n\t\tif (attnum <= 0 || attnum >= num_col_privileges)\n\t\t\telog(ERROR, \"column number out of range\");\t\n\t\tcol_privileges[attnum] |= this_privileges;\n\t}\n}\n\n\nstatic void\nexpand_all_col_privileges(Oid table_oid, Form_pg_class classForm,\n\t\t\t\t\t\t  AclMode this_privileges,\n\t\t\t\t\t\t  AclMode *col_privileges,\n\t\t\t\t\t\t  int num_col_privileges)\n{\n\tAttrNumber\tcurr_att;\n\n\tAssert(classForm->relnatts - FirstLowInvalidHeapAttributeNumber < num_col_privileges);\n\tfor (curr_att = FirstLowInvalidHeapAttributeNumber + 1;\n\t\t curr_att <= classForm->relnatts;\n\t\t curr_att++)\n\t{\n\t\tHeapTuple\tattTuple;\n\t\tbool\t\tisdropped;\n\n\t\tif (curr_att == InvalidAttrNumber)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (classForm->relkind == RELKIND_VIEW && curr_att < 0)\n\t\t\tcontinue;\n\n\t\t\n\t\tif ((classForm->relam == AO_COLUMN_TABLE_AM_OID || classForm->relam == AO_ROW_TABLE_AM_OID) &&\n\t\t\t(curr_att >= -5) && (curr_att <=-2))\n\t\t\tcontinue;\n\n\t\tattTuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(table_oid),\n\t\t\t\t\t\t\t\t   Int16GetDatum(curr_att));\n\t\tif (!HeapTupleIsValid(attTuple))\n\t\t\telog(ERROR, \"cache lookup failed for attribute %d of relation %u\",\n\t\t\t\t curr_att, table_oid);\n\n\t\tisdropped = ((Form_pg_attribute) GETSTRUCT(attTuple))->attisdropped;\n\n\t\tReleaseSysCache(attTuple);\n\n\t\t\n\t\tif (isdropped)\n\t\t\tcontinue;\n\n\t\tcol_privileges[curr_att - FirstLowInvalidHeapAttributeNumber] |= this_privileges;\n\t}\n}\n\n\nstatic void\nExecGrant_Attribute(InternalGrant *istmt, Oid relOid, const char *relname,\n\t\t\t\t\tAttrNumber attnum, Oid ownerId, AclMode col_privileges,\n\t\t\t\t\tRelation attRelation, const Acl *old_rel_acl)\n{\n\tHeapTuple\tattr_tuple;\n\tForm_pg_attribute pg_attribute_tuple;\n\tAcl\t\t   *old_acl;\n\tAcl\t\t   *new_acl;\n\tAcl\t\t   *merged_acl;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tOid\t\t\tgrantorId;\n\tAclMode\t\tavail_goptions;\n\tbool\t\tneed_update;\n\tHeapTuple\tnewtuple;\n\tDatum\t\tvalues[Natts_pg_attribute];\n\tbool\t\tnulls[Natts_pg_attribute];\n\tbool\t\treplaces[Natts_pg_attribute];\n\tint\t\t\tnoldmembers;\n\tint\t\t\tnnewmembers;\n\tOid\t\t   *oldmembers;\n\tOid\t\t   *newmembers;\n\n\tattr_tuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t\t ObjectIdGetDatum(relOid),\n\t\t\t\t\t\t\t\t Int16GetDatum(attnum));\n\tif (!HeapTupleIsValid(attr_tuple))\n\t\telog(ERROR, \"cache lookup failed for attribute %d of relation %u\",\n\t\t\t attnum, relOid);\n\tpg_attribute_tuple = (Form_pg_attribute) GETSTRUCT(attr_tuple);\n\n\t\n\taclDatum = SysCacheGetAttr(ATTNUM, attr_tuple, Anum_pg_attribute_attacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\told_acl = acldefault(OBJECT_COLUMN, ownerId);\n\t\t\n\t\tnoldmembers = 0;\n\t\toldmembers = NULL;\n\t}\n\telse\n\t{\n\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\n\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t}\n\n\t\n\tmerged_acl = aclconcat(old_rel_acl, old_acl);\n\n\t\n\tselect_best_grantor(GetUserId(), col_privileges,\n\t\t\t\t\t\tmerged_acl, ownerId,\n\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\tpfree(merged_acl);\n\n\t\n\tcol_privileges =\n\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t (col_privileges == ACL_ALL_RIGHTS_COLUMN),\n\t\t\t\t\t\t\t\t col_privileges,\n\t\t\t\t\t\t\t\t relOid, grantorId, OBJECT_COLUMN,\n\t\t\t\t\t\t\t\t relname, attnum,\n\t\t\t\t\t\t\t\t NameStr(pg_attribute_tuple->attname));\n\n\t\n\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t   istmt->grant_option,\n\t\t\t\t\t\t\t\t   istmt->behavior, istmt->grantees,\n\t\t\t\t\t\t\t\t   col_privileges, grantorId,\n\t\t\t\t\t\t\t\t   ownerId);\n\n\t\n\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\n\tMemSet(values, 0, sizeof(values));\n\tMemSet(nulls, false, sizeof(nulls));\n\tMemSet(replaces, false, sizeof(replaces));\n\n\t\n\tif (ACL_NUM(new_acl) > 0)\n\t{\n\t\tvalues[Anum_pg_attribute_attacl - 1] = PointerGetDatum(new_acl);\n\t\tneed_update = true;\n\t}\n\telse\n\t{\n\t\tnulls[Anum_pg_attribute_attacl - 1] = true;\n\t\tneed_update = !isNull;\n\t}\n\treplaces[Anum_pg_attribute_attacl - 1] = true;\n\n\tif (need_update)\n\t{\n\t\tnewtuple = heap_modify_tuple(attr_tuple, RelationGetDescr(attRelation),\n\t\t\t\t\t\t\t\t\t values, nulls, replaces);\n\n\t\tCatalogTupleUpdate(attRelation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(relOid, RelationRelationId, attnum,\n\t\t\t\t\t\t\t\tACL_NUM(new_acl) > 0 ? new_acl : NULL);\n\n\t\t\n\t\tupdateAclDependencies(RelationRelationId, relOid, attnum,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\t}\n\n\tpfree(new_acl);\n\n\tReleaseSysCache(attr_tuple);\n}\n\n\nstatic void\nExecGrant_Relation(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tRelation\tattRelation;\n\tListCell   *cell;\n\n\trelation = table_open(RelationRelationId, RowExclusiveLock);\n\tattRelation = table_open(AttributeRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\trelOid = lfirst_oid(cell);\n\t\tDatum\t\taclDatum;\n\t\tForm_pg_class pg_class_tuple;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tthis_privileges;\n\t\tAclMode    *col_privileges;\n\t\tint\t\t\tnum_col_privileges;\n\t\tbool\t\thave_col_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *old_rel_acl;\n\t\tint\t\t\tnoldmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tListCell   *cell_colprivs;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relOid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relOid);\n\t\tpg_class_tuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_INDEX ||\n\t\t\tpg_class_tuple->relkind == RELKIND_PARTITIONED_INDEX)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is an index\",\n\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname))));\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_COMPOSITE_TYPE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is a composite type\",\n\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname))));\n\n\t\t\n\t\tif (istmt->objtype == OBJECT_SEQUENCE &&\n\t\t\tpg_class_tuple->relkind != RELKIND_SEQUENCE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a sequence\",\n\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname))));\n\n\t\t\n\t\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\t{\n\t\t\tif (pg_class_tuple->relkind == RELKIND_SEQUENCE)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\telse\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_RELATION;\n\t\t}\n\t\telse\n\t\t\tthis_privileges = istmt->privileges;\n\n\t\t\n\t\tif (istmt->objtype == OBJECT_TABLE)\n\t\t{\n\t\t\tif (pg_class_tuple->relkind == RELKIND_SEQUENCE)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (this_privileges & ~((AclMode) ACL_ALL_RIGHTS_SEQUENCE))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t\t errmsg(\"sequence \\\"%s\\\" only supports USAGE, SELECT, and UPDATE privileges\",\n\t\t\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname))));\n\t\t\t\t\tthis_privileges &= (AclMode) ACL_ALL_RIGHTS_SEQUENCE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this_privileges & ~((AclMode) ACL_ALL_RIGHTS_RELATION))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t\t errmsg(\"invalid privilege type %s for table\",\n\t\t\t\t\t\t\t\t\t\"USAGE\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tnum_col_privileges = pg_class_tuple->relnatts - FirstLowInvalidHeapAttributeNumber + 1;\n\t\tcol_privileges = (AclMode *) palloc0(num_col_privileges * sizeof(AclMode));\n\t\thave_col_privileges = false;\n\n\t\t\n\t\tif (!istmt->is_grant &&\n\t\t\t(this_privileges & ACL_ALL_RIGHTS_COLUMN) != 0)\n\t\t{\n\t\t\texpand_all_col_privileges(relOid, pg_class_tuple,\n\t\t\t\t\t\t\t\t\t  this_privileges & ACL_ALL_RIGHTS_COLUMN,\n\t\t\t\t\t\t\t\t\t  col_privileges,\n\t\t\t\t\t\t\t\t\t  num_col_privileges);\n\t\t\thave_col_privileges = true;\n\t\t}\n\n\t\t\n\t\townerId = pg_class_tuple->relowner;\n\t\taclDatum = SysCacheGetAttr(RELOID, tuple, Anum_pg_class_relacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\tswitch (pg_class_tuple->relkind)\n\t\t\t{\n\t\t\t\tcase RELKIND_SEQUENCE:\n\t\t\t\t\told_acl = acldefault(OBJECT_SEQUENCE, ownerId);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\told_acl = acldefault(OBJECT_TABLE, ownerId);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\told_rel_acl = aclcopy(old_acl);\n\n\t\t\n\t\tif (this_privileges != ACL_NO_RIGHTS)\n\t\t{\n\t\t\tAclMode\t\tavail_goptions;\n\t\t\tAcl\t\t   *new_acl;\n\t\t\tOid\t\t\tgrantorId;\n\t\t\tHeapTuple\tnewtuple;\n\t\t\tDatum\t\tvalues[Natts_pg_class];\n\t\t\tbool\t\tnulls[Natts_pg_class];\n\t\t\tbool\t\treplaces[Natts_pg_class];\n\t\t\tint\t\t\tnnewmembers;\n\t\t\tOid\t\t   *newmembers;\n\t\t\tObjectType\tobjtype;\n\n\t\t\t\n\t\t\tselect_best_grantor(GetUserId(), this_privileges,\n\t\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\tswitch (pg_class_tuple->relkind)\n\t\t\t{\n\t\t\t\tcase RELKIND_SEQUENCE:\n\t\t\t\t\tobjtype = OBJECT_SEQUENCE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tobjtype = OBJECT_TABLE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\n\t\t\tthis_privileges =\n\t\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t\t istmt->all_privs, this_privileges,\n\t\t\t\t\t\t\t\t\t\t relOid, grantorId, objtype,\n\t\t\t\t\t\t\t\t\t\t NameStr(pg_class_tuple->relname),\n\t\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\t\n\t\t\tnew_acl = merge_acl_with_grant(old_acl,\n\t\t\t\t\t\t\t\t\t\t   istmt->is_grant,\n\t\t\t\t\t\t\t\t\t\t   istmt->grant_option,\n\t\t\t\t\t\t\t\t\t\t   istmt->behavior,\n\t\t\t\t\t\t\t\t\t\t   istmt->grantees,\n\t\t\t\t\t\t\t\t\t\t   this_privileges,\n\t\t\t\t\t\t\t\t\t\t   grantorId,\n\t\t\t\t\t\t\t\t\t\t   ownerId);\n\n\t\t\t\n\t\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\t\n\t\t\tMemSet(values, 0, sizeof(values));\n\t\t\tMemSet(nulls, false, sizeof(nulls));\n\t\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\t\treplaces[Anum_pg_class_relacl - 1] = true;\n\t\t\tvalues[Anum_pg_class_relacl - 1] = PointerGetDatum(new_acl);\n\n\t\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t\t values, nulls, replaces);\n\n\t\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\t\n\t\t\trecordExtensionInitPriv(relOid, RelationRelationId, 0, new_acl);\n\n\t\t\t\n\t\t\tupdateAclDependencies(RelationRelationId, relOid, 0,\n\t\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\t\tpfree(new_acl);\n\t\t}\n\n\t\t\n\t\tforeach(cell_colprivs, istmt->col_privs)\n\t\t{\n\t\t\tAccessPriv *col_privs = (AccessPriv *) lfirst(cell_colprivs);\n\n\t\t\tif (col_privs->priv_name == NULL)\n\t\t\t\tthis_privileges = ACL_ALL_RIGHTS_COLUMN;\n\t\t\telse\n\t\t\t\tthis_privileges = string_to_privilege(col_privs->priv_name);\n\n\t\t\tif (this_privileges & ~((AclMode) ACL_ALL_RIGHTS_COLUMN))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(\"invalid privilege type %s for column\",\n\t\t\t\t\t\t\t\tprivilege_to_string(this_privileges))));\n\n\t\t\tif (pg_class_tuple->relkind == RELKIND_SEQUENCE &&\n\t\t\t\tthis_privileges & ~((AclMode) ACL_SELECT))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t\t errmsg(\"sequence \\\"%s\\\" only supports SELECT column privileges\",\n\t\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname))));\n\n\t\t\t\tthis_privileges &= (AclMode) ACL_SELECT;\n\t\t\t}\n\n\t\t\texpand_col_privileges(col_privs->cols, relOid,\n\t\t\t\t\t\t\t\t  this_privileges,\n\t\t\t\t\t\t\t\t  col_privileges,\n\t\t\t\t\t\t\t\t  num_col_privileges);\n\t\t\thave_col_privileges = true;\n\t\t}\n\n\t\tif (have_col_privileges)\n\t\t{\n\t\t\tAttrNumber\ti;\n\n\t\t\tfor (i = 0; i < num_col_privileges; i++)\n\t\t\t{\n\t\t\t\tif (col_privileges[i] == ACL_NO_RIGHTS)\n\t\t\t\t\tcontinue;\n\t\t\t\tExecGrant_Attribute(istmt,\n\t\t\t\t\t\t\t\t\trelOid,\n\t\t\t\t\t\t\t\t\tNameStr(pg_class_tuple->relname),\n\t\t\t\t\t\t\t\t\ti + FirstLowInvalidHeapAttributeNumber,\n\t\t\t\t\t\t\t\t\townerId,\n\t\t\t\t\t\t\t\t\tcol_privileges[i],\n\t\t\t\t\t\t\t\t\tattRelation,\n\t\t\t\t\t\t\t\t\told_rel_acl);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (Gp_role == GP_ROLE_DISPATCH)\n\t\t{\n\t\t\tbool\t\tbTemp = isAnyTempNamespace(pg_class_tuple->relnamespace);\n\n\t\t\t\n\t\t\tif (!bTemp\n\t\t\t\t&& ((pg_class_tuple->relkind == RELKIND_INDEX) ||\n\t\t\t\t\t(pg_class_tuple->relkind == RELKIND_RELATION) ||\n\t\t\t\t\t(pg_class_tuple->relkind == RELKIND_SEQUENCE) ||\n\t\t\t\t\t(pg_class_tuple->relkind == RELKIND_VIEW)))\n\t\t\t\tMetaTrackUpdObject(RelationRelationId,\n\t\t\t\t\t\t\t\t   relOid,\n\t\t\t\t\t\t\t\t   GetUserId(), \n\t\t\t\t\t\t\t\t   \"PRIVILEGE\",\n\t\t\t\t\t\t\t\t   (istmt->is_grant) ? \"GRANT\" : \"REVOKE\"\n\t\t\t\t\t);\n\t\t}\n\n\t\tpfree(old_rel_acl);\n\t\tpfree(col_privileges);\n\n\t\tReleaseSysCache(tuple);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(attRelation, RowExclusiveLock);\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Database(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_DATABASE;\n\n\trelation = table_open(DatabaseRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tdatId = lfirst_oid(cell);\n\t\tForm_pg_database pg_database_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_database];\n\t\tbool\t\tnulls[Natts_pg_database];\n\t\tbool\t\treplaces[Natts_pg_database];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(datId));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for database %u\", datId);\n\n\t\tpg_database_tuple = (Form_pg_database) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_database_tuple->datdba;\n\t\taclDatum = heap_getattr(tuple, Anum_pg_database_datacl,\n\t\t\t\t\t\t\t\tRelationGetDescr(relation), &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_DATABASE, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t datId, grantorId, OBJECT_DATABASE,\n\t\t\t\t\t\t\t\t\t NameStr(pg_database_tuple->datname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_database_datacl - 1] = true;\n\t\tvalues[Anum_pg_database_datacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\tif (Gp_role == GP_ROLE_DISPATCH)\n\t\t\tMetaTrackUpdObject(DatabaseRelationId,\n\t\t\t\t\t\t\t   datId,\n\t\t\t\t\t\t\t   GetUserId(), \n\t\t\t\t\t\t\t   \"PRIVILEGE\", \n\t\t\t\t\t\t\t   (istmt->is_grant) ? \"GRANT\" : \"REVOKE\"\n\t\t\t\t\t);\n\n\t\t\n\t\tupdateAclDependencies(DatabaseRelationId, pg_database_tuple->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Fdw(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_FDW;\n\n\trelation = table_open(ForeignDataWrapperRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tfdwid = lfirst_oid(cell);\n\t\tForm_pg_foreign_data_wrapper pg_fdw_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_foreign_data_wrapper];\n\t\tbool\t\tnulls[Natts_pg_foreign_data_wrapper];\n\t\tbool\t\treplaces[Natts_pg_foreign_data_wrapper];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\n\t\ttuple = SearchSysCache1(FOREIGNDATAWRAPPEROID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(fdwid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for foreign-data wrapper %u\", fdwid);\n\n\t\tpg_fdw_tuple = (Form_pg_foreign_data_wrapper) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_fdw_tuple->fdwowner;\n\t\taclDatum = SysCacheGetAttr(FOREIGNDATAWRAPPEROID, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_foreign_data_wrapper_fdwacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_FDW, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t fdwid, grantorId, OBJECT_FDW,\n\t\t\t\t\t\t\t\t\t NameStr(pg_fdw_tuple->fdwname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_foreign_data_wrapper_fdwacl - 1] = true;\n\t\tvalues[Anum_pg_foreign_data_wrapper_fdwacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(fdwid, ForeignDataWrapperRelationId, 0,\n\t\t\t\t\t\t\t\tnew_acl);\n\n\t\t\n\t\tupdateAclDependencies(ForeignDataWrapperRelationId,\n\t\t\t\t\t\t\t  pg_fdw_tuple->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_ForeignServer(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_FOREIGN_SERVER;\n\n\trelation = table_open(ForeignServerRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tsrvid = lfirst_oid(cell);\n\t\tForm_pg_foreign_server pg_server_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_foreign_server];\n\t\tbool\t\tnulls[Natts_pg_foreign_server];\n\t\tbool\t\treplaces[Natts_pg_foreign_server];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\n\t\ttuple = SearchSysCache1(FOREIGNSERVEROID, ObjectIdGetDatum(srvid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for foreign server %u\", srvid);\n\n\t\tpg_server_tuple = (Form_pg_foreign_server) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_server_tuple->srvowner;\n\t\taclDatum = SysCacheGetAttr(FOREIGNSERVEROID, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_foreign_server_srvacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_FOREIGN_SERVER, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t srvid, grantorId, OBJECT_FOREIGN_SERVER,\n\t\t\t\t\t\t\t\t\t NameStr(pg_server_tuple->srvname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_foreign_server_srvacl - 1] = true;\n\t\tvalues[Anum_pg_foreign_server_srvacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(srvid, ForeignServerRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(ForeignServerRelationId,\n\t\t\t\t\t\t\t  pg_server_tuple->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Function(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_FUNCTION;\n\n\trelation = table_open(ProcedureRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tfuncId = lfirst_oid(cell);\n\t\tForm_pg_proc pg_proc_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_proc];\n\t\tbool\t\tnulls[Natts_pg_proc];\n\t\tbool\t\treplaces[Natts_pg_proc];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\n\t\ttuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcId));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\", funcId);\n\n\t\tpg_proc_tuple = (Form_pg_proc) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_proc_tuple->proowner;\n\t\taclDatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_proacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_FUNCTION, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t funcId, grantorId, OBJECT_FUNCTION,\n\t\t\t\t\t\t\t\t\t NameStr(pg_proc_tuple->proname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_proc_proacl - 1] = true;\n\t\tvalues[Anum_pg_proc_proacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(funcId, ProcedureRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(ProcedureRelationId, funcId, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Language(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_LANGUAGE;\n\n\trelation = table_open(LanguageRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tlangId = lfirst_oid(cell);\n\t\tForm_pg_language pg_language_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_language];\n\t\tbool\t\tnulls[Natts_pg_language];\n\t\tbool\t\treplaces[Natts_pg_language];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\n\t\ttuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(langId));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for language %u\", langId);\n\n\t\tpg_language_tuple = (Form_pg_language) GETSTRUCT(tuple);\n\n\t\tif (!pg_language_tuple->lanpltrusted)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"language \\\"%s\\\" is not trusted\",\n\t\t\t\t\t\t\tNameStr(pg_language_tuple->lanname)),\n\t\t\t\t\t errdetail(\"GRANT and REVOKE are not allowed on untrusted languages, \"\n\t\t\t\t\t\t\t   \"because only superusers can use untrusted languages.\")));\n\n\t\t\n\t\townerId = pg_language_tuple->lanowner;\n\t\taclDatum = SysCacheGetAttr(LANGNAME, tuple, Anum_pg_language_lanacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_LANGUAGE, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t langId, grantorId, OBJECT_LANGUAGE,\n\t\t\t\t\t\t\t\t\t NameStr(pg_language_tuple->lanname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_language_lanacl - 1] = true;\n\t\tvalues[Anum_pg_language_lanacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(langId, LanguageRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(LanguageRelationId, pg_language_tuple->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Largeobject(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_LARGEOBJECT;\n\n\trelation = table_open(LargeObjectMetadataRelationId,\n\t\t\t\t\t\t  RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tloid = lfirst_oid(cell);\n\t\tForm_pg_largeobject_metadata form_lo_meta;\n\t\tchar\t\tloname[NAMEDATALEN];\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_largeobject_metadata];\n\t\tbool\t\tnulls[Natts_pg_largeobject_metadata];\n\t\tbool\t\treplaces[Natts_pg_largeobject_metadata];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\t\tScanKeyData entry[1];\n\t\tSysScanDesc scan;\n\t\tHeapTuple\ttuple;\n\n\t\t\n\t\tScanKeyInit(&entry[0],\n\t\t\t\t\tAnum_pg_largeobject_metadata_oid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(loid));\n\n\t\tscan = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  LargeObjectMetadataOidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, entry);\n\n\t\ttuple = systable_getnext(scan);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"could not find tuple for large object %u\", loid);\n\n\t\tform_lo_meta = (Form_pg_largeobject_metadata) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = form_lo_meta->lomowner;\n\t\taclDatum = heap_getattr(tuple,\n\t\t\t\t\t\t\t\tAnum_pg_largeobject_metadata_lomacl,\n\t\t\t\t\t\t\t\tRelationGetDescr(relation), &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_LARGEOBJECT, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tsnprintf(loname, sizeof(loname), \"large object %u\", loid);\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t loid, grantorId, OBJECT_LARGEOBJECT,\n\t\t\t\t\t\t\t\t\t loname, 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_largeobject_metadata_lomacl - 1] = true;\n\t\tvalues[Anum_pg_largeobject_metadata_lomacl - 1]\n\t\t\t= PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t values, nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(loid, LargeObjectRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(LargeObjectRelationId,\n\t\t\t\t\t\t\t  form_lo_meta->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tsystable_endscan(scan);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Namespace(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_SCHEMA;\n\n\trelation = table_open(NamespaceRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tForm_pg_namespace pg_namespace_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\ttuple;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_namespace];\n\t\tbool\t\tnulls[Natts_pg_namespace];\n\t\tbool\t\treplaces[Natts_pg_namespace];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\n\t\ttuple = SearchSysCache1(NAMESPACEOID, ObjectIdGetDatum(nspid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for namespace %u\", nspid);\n\n\t\tpg_namespace_tuple = (Form_pg_namespace) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_namespace_tuple->nspowner;\n\t\taclDatum = SysCacheGetAttr(NAMESPACENAME, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_namespace_nspacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_SCHEMA, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t nspid, grantorId, OBJECT_SCHEMA,\n\t\t\t\t\t\t\t\t\t NameStr(pg_namespace_tuple->nspname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_namespace_nspacl - 1] = true;\n\t\tvalues[Anum_pg_namespace_nspacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\tif (Gp_role == GP_ROLE_DISPATCH)\n\t\t\tMetaTrackUpdObject(NamespaceRelationId,\n\t\t\t\t\t\t\t   nspid,\n\t\t\t\t\t\t\t   GetUserId(), \n\t\t\t\t\t\t\t   \"PRIVILEGE\", \n\t\t\t\t\t\t\t   (istmt->is_grant) ? \"GRANT\" : \"REVOKE\"\n\t\t\t\t\t);\n\n\t\t\n\t\trecordExtensionInitPriv(nspid, NamespaceRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(NamespaceRelationId, pg_namespace_tuple->oid, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Tablespace(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_TABLESPACE;\n\n\trelation = table_open(TableSpaceRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\ttblId = lfirst_oid(cell);\n\t\tForm_pg_tablespace pg_tablespace_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_tablespace];\n\t\tbool\t\tnulls[Natts_pg_tablespace];\n\t\tbool\t\treplaces[Natts_pg_tablespace];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\t\tHeapTuple\ttuple;\n\n\t\t\n\t\ttuple = SearchSysCache1(TABLESPACEOID, ObjectIdGetDatum(tblId));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for tablespace %u\", tblId);\n\n\t\tpg_tablespace_tuple = (Form_pg_tablespace) GETSTRUCT(tuple);\n\n\t\t\n\t\townerId = pg_tablespace_tuple->spcowner;\n\t\taclDatum = heap_getattr(tuple, Anum_pg_tablespace_spcacl,\n\t\t\t\t\t\t\t\tRelationGetDescr(relation), &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(OBJECT_TABLESPACE, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t tblId, grantorId, OBJECT_TABLESPACE,\n\t\t\t\t\t\t\t\t\t NameStr(pg_tablespace_tuple->spcname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_tablespace_spcacl - 1] = true;\n\t\tvalues[Anum_pg_tablespace_spcacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\tif (Gp_role == GP_ROLE_DISPATCH)\n\t\t\tMetaTrackUpdObject(TableSpaceRelationId,\n\t\t\t\t\t\t\t   tblId,\n\t\t\t\t\t\t\t   GetUserId(), \n\t\t\t\t\t\t\t   \"PRIVILEGE\", \n\t\t\t\t\t\t\t   (istmt->is_grant) ? \"GRANT\" : \"REVOKE\"\n\t\t\t\t\t);\n\n\t\t\n\t\tupdateAclDependencies(TableSpaceRelationId, tblId, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_Type(InternalGrant *istmt)\n{\n\tRelation\trelation;\n\tListCell   *cell;\n\n\tif (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n\t\tistmt->privileges = ACL_ALL_RIGHTS_TYPE;\n\n\trelation = table_open(TypeRelationId, RowExclusiveLock);\n\n\tforeach(cell, istmt->objects)\n\t{\n\t\tOid\t\t\ttypId = lfirst_oid(cell);\n\t\tForm_pg_type pg_type_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tAclMode\t\tavail_goptions;\n\t\tAclMode\t\tthis_privileges;\n\t\tAcl\t\t   *old_acl;\n\t\tAcl\t\t   *new_acl;\n\t\tOid\t\t\tgrantorId;\n\t\tOid\t\t\townerId;\n\t\tHeapTuple\tnewtuple;\n\t\tDatum\t\tvalues[Natts_pg_type];\n\t\tbool\t\tnulls[Natts_pg_type];\n\t\tbool\t\treplaces[Natts_pg_type];\n\t\tint\t\t\tnoldmembers;\n\t\tint\t\t\tnnewmembers;\n\t\tOid\t\t   *oldmembers;\n\t\tOid\t\t   *newmembers;\n\t\tHeapTuple\ttuple;\n\n\t\t\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typId));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typId);\n\n\t\tpg_type_tuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\tif (pg_type_tuple->typelem != 0 && pg_type_tuple->typlen == -1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_GRANT_OPERATION),\n\t\t\t\t\t errmsg(\"cannot set privileges of array types\"),\n\t\t\t\t\t errhint(\"Set the privileges of the element type instead.\")));\n\n\t\t\n\t\tif (istmt->objtype == OBJECT_DOMAIN &&\n\t\t\tpg_type_tuple->typtype != TYPTYPE_DOMAIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a domain\",\n\t\t\t\t\t\t\tNameStr(pg_type_tuple->typname))));\n\n\t\t\n\t\townerId = pg_type_tuple->typowner;\n\t\taclDatum = heap_getattr(tuple, Anum_pg_type_typacl,\n\t\t\t\t\t\t\t\tRelationGetDescr(relation), &isNull);\n\t\tif (isNull)\n\t\t{\n\t\t\told_acl = acldefault(istmt->objtype, ownerId);\n\t\t\t\n\t\t\tnoldmembers = 0;\n\t\t\toldmembers = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\told_acl = DatumGetAclPCopy(aclDatum);\n\t\t\t\n\t\t\tnoldmembers = aclmembers(old_acl, &oldmembers);\n\t\t}\n\n\t\t\n\t\tselect_best_grantor(GetUserId(), istmt->privileges,\n\t\t\t\t\t\t\told_acl, ownerId,\n\t\t\t\t\t\t\t&grantorId, &avail_goptions);\n\n\t\t\n\t\tthis_privileges =\n\t\t\trestrict_and_check_grant(istmt->is_grant, avail_goptions,\n\t\t\t\t\t\t\t\t\t istmt->all_privs, istmt->privileges,\n\t\t\t\t\t\t\t\t\t typId, grantorId, OBJECT_TYPE,\n\t\t\t\t\t\t\t\t\t NameStr(pg_type_tuple->typname),\n\t\t\t\t\t\t\t\t\t 0, NULL);\n\n\t\t\n\t\tnew_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n\t\t\t\t\t\t\t\t\t   istmt->grant_option, istmt->behavior,\n\t\t\t\t\t\t\t\t\t   istmt->grantees, this_privileges,\n\t\t\t\t\t\t\t\t\t   grantorId, ownerId);\n\n\t\t\n\t\tnnewmembers = aclmembers(new_acl, &newmembers);\n\n\t\t\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_type_typacl - 1] = true;\n\t\tvalues[Anum_pg_type_typacl - 1] = PointerGetDatum(new_acl);\n\n\t\tnewtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n\t\t\t\t\t\t\t\t\t nulls, replaces);\n\n\t\tCatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n\t\t\n\t\trecordExtensionInitPriv(typId, TypeRelationId, 0, new_acl);\n\n\t\t\n\t\tupdateAclDependencies(TypeRelationId, typId, 0,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  noldmembers, oldmembers,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(tuple);\n\t\tpfree(new_acl);\n\n\t\t\n\t\tCommandCounterIncrement();\n\t}\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\nstatic void\nExecGrant_ExtProtocol(InternalGrant *istmt)\n{\n    Relation\trelation;\n    ListCell   *cell;\n\n    if (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS)\n        istmt->privileges = ACL_ALL_RIGHTS_EXTPROTOCOL;\n\n    relation = table_open(ExtprotocolRelationId, RowExclusiveLock);\n\n    foreach(cell, istmt->objects)\n    {\n        Oid\t\t\tptcid = lfirst_oid(cell);\n        bool\t\tisNull;\n        bool\t\tisTrusted;\n        AclMode\t\tavail_goptions;\n        AclMode\t\tthis_privileges;\n        Acl\t\t   *old_acl;\n        Acl\t\t   *new_acl;\n        Oid\t\t\tgrantorId;\n        Oid\t\t\townerId;\n        Name\t    ptcname;\n        HeapTuple\ttuple;\n        HeapTuple\tnewtuple;\n        Datum\t\tvalues[Natts_pg_extprotocol];\n        bool\t\tnulls[Natts_pg_extprotocol];\n        bool\t\treplaces[Natts_pg_extprotocol];\n        int\t\t\tnoldmembers;\n        int\t\t\tnnewmembers;\n        Oid\t\t   *oldmembers;\n        Oid\t\t   *newmembers;\n        Datum\t\townerDatum;\n        Datum\t\taclDatum;\n        Datum\t\ttrustedDatum;\n        Datum\t\tptcnameDatum;\n        ScanKeyData entry[1];\n        SysScanDesc scan;\n        TupleDesc\treldsc = RelationGetDescr(relation);\n\n        \n        ScanKeyInit(&entry[0],\n                    Anum_pg_extprotocol_oid,\n                    BTEqualStrategyNumber, F_OIDEQ,\n                    ObjectIdGetDatum(ptcid));\n        scan = systable_beginscan(relation, ExtprotocolOidIndexId, true,\n                                  NULL, 1, entry);\n        tuple = systable_getnext(scan);\n        if (!HeapTupleIsValid(tuple))\n            elog(ERROR, \"lookup failed for external protocol %u\", ptcid);\n\n        ownerDatum = heap_getattr(tuple,\n                                  Anum_pg_extprotocol_ptcowner,\n                                  reldsc,\n                                  &isNull);\n\n        if(isNull)\n            ereport(ERROR,\n                    (errcode(ERRCODE_UNDEFINED_OBJECT),\n                            errmsg(\"protocol '%u' has no owner defined\",\n                                   ptcid)));\n\n        \n        ownerId = DatumGetObjectId(ownerDatum);\n\n        aclDatum = heap_getattr(tuple,\n                                Anum_pg_extprotocol_ptcacl,\n                                reldsc,\n                                &isNull);\n\n        if (isNull)\n            old_acl = acldefault(OBJECT_EXTPROTOCOL, ownerId);\n        else\n            old_acl = DatumGetAclPCopy(aclDatum);\n\n        ptcnameDatum = heap_getattr(tuple,\n                                    Anum_pg_extprotocol_ptcname,\n                                    reldsc,\n                                    &isNull);\n\n        ptcname = DatumGetName(ptcnameDatum);\n\n        if(isNull)\n            ereport(ERROR,\n                    (errcode(ERRCODE_UNDEFINED_OBJECT),\n                            errmsg(\"internal error: protocol '%u' has no name defined\",\n                                   ptcid)));\n\n        trustedDatum = heap_getattr(tuple,\n                                    Anum_pg_extprotocol_ptctrusted,\n                                    reldsc,\n                                    &isNull);\n\n        isTrusted = DatumGetBool(trustedDatum);\n\n        if (!isTrusted)\n            ereport(ERROR,\n                    (errcode(ERRCODE_WRONG_OBJECT_TYPE),\n                            errmsg(\"protocol \\\"%s\\\" is not trusted\",\n                                   NameStr(*ptcname)),\n                            errhint(\"Only superusers may use untrusted protocols.\")));\n\n        \n        select_best_grantor(GetUserId(), istmt->privileges,\n                            old_acl, ownerId,\n                            &grantorId, &avail_goptions);\n\n        \n        this_privileges =\n                restrict_and_check_grant(istmt->is_grant, avail_goptions,\n                                         istmt->all_privs, istmt->privileges,\n                                         ptcid, grantorId, OBJECT_EXTPROTOCOL,\n                                         NameStr(*ptcname),\n                                         0, NULL);\n\n        \n        noldmembers = aclmembers(old_acl, &oldmembers);\n\n        new_acl = merge_acl_with_grant(old_acl, istmt->is_grant,\n                                       istmt->grant_option, istmt->behavior,\n                                       istmt->grantees, this_privileges,\n                                       grantorId, ownerId);\n\n        nnewmembers = aclmembers(new_acl, &newmembers);\n\n        \n        MemSet(values, 0, sizeof(values));\n        MemSet(nulls, false, sizeof(nulls));\n        MemSet(replaces, false, sizeof(replaces));\n\n        replaces[Anum_pg_extprotocol_ptcacl - 1] = true;\n        values[Anum_pg_extprotocol_ptcacl - 1] = PointerGetDatum(new_acl);\n\n        newtuple = heap_modify_tuple(tuple, RelationGetDescr(relation), values,\n                                     nulls, replaces);\n\n        CatalogTupleUpdate(relation, &newtuple->t_self, newtuple);\n\n        \n        updateAclDependencies(ExtprotocolRelationId, ptcid, 0,\n                              ownerId,\n                              noldmembers, oldmembers,\n                              nnewmembers, newmembers);\n\n        systable_endscan(scan);\n\n        pfree(new_acl);\n\n        \n        CommandCounterIncrement();\n    }\n\n    table_close(relation, RowExclusiveLock);\n}\n\nstatic AclMode\nstring_to_privilege(const char *privname)\n{\n\tif (strcmp(privname, \"insert\") == 0)\n\t\treturn ACL_INSERT;\n\tif (strcmp(privname, \"select\") == 0)\n\t\treturn ACL_SELECT;\n\tif (strcmp(privname, \"update\") == 0)\n\t\treturn ACL_UPDATE;\n\tif (strcmp(privname, \"delete\") == 0)\n\t\treturn ACL_DELETE;\n\tif (strcmp(privname, \"truncate\") == 0)\n\t\treturn ACL_TRUNCATE;\n\tif (strcmp(privname, \"references\") == 0)\n\t\treturn ACL_REFERENCES;\n\tif (strcmp(privname, \"trigger\") == 0)\n\t\treturn ACL_TRIGGER;\n\tif (strcmp(privname, \"execute\") == 0)\n\t\treturn ACL_EXECUTE;\n\tif (strcmp(privname, \"usage\") == 0)\n\t\treturn ACL_USAGE;\n\tif (strcmp(privname, \"create\") == 0)\n\t\treturn ACL_CREATE;\n\tif (strcmp(privname, \"temporary\") == 0)\n\t\treturn ACL_CREATE_TEMP;\n\tif (strcmp(privname, \"temp\") == 0)\n\t\treturn ACL_CREATE_TEMP;\n\tif (strcmp(privname, \"connect\") == 0)\n\t\treturn ACL_CONNECT;\n\tif (strcmp(privname, \"rule\") == 0)\n\t\treturn 0;\t\t\t\t\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t errmsg(\"unrecognized privilege type \\\"%s\\\"\", privname)));\n\treturn 0;\t\t\t\t\t\n}\n\nstatic const char *\nprivilege_to_string(AclMode privilege)\n{\n\tswitch (privilege)\n\t{\n\t\tcase ACL_INSERT:\n\t\t\treturn \"INSERT\";\n\t\tcase ACL_SELECT:\n\t\t\treturn \"SELECT\";\n\t\tcase ACL_UPDATE:\n\t\t\treturn \"UPDATE\";\n\t\tcase ACL_DELETE:\n\t\t\treturn \"DELETE\";\n\t\tcase ACL_TRUNCATE:\n\t\t\treturn \"TRUNCATE\";\n\t\tcase ACL_REFERENCES:\n\t\t\treturn \"REFERENCES\";\n\t\tcase ACL_TRIGGER:\n\t\t\treturn \"TRIGGER\";\n\t\tcase ACL_EXECUTE:\n\t\t\treturn \"EXECUTE\";\n\t\tcase ACL_USAGE:\n\t\t\treturn \"USAGE\";\n\t\tcase ACL_CREATE:\n\t\t\treturn \"CREATE\";\n\t\tcase ACL_CREATE_TEMP:\n\t\t\treturn \"TEMP\";\n\t\tcase ACL_CONNECT:\n\t\t\treturn \"CONNECT\";\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized privilege: %d\", (int) privilege);\n\t}\n\treturn NULL;\t\t\t\t\n}\n\n\nvoid\naclcheck_error(AclResult aclerr, ObjectType objtype,\n\t\t\t   const char *objectname)\n{\n\tswitch (aclerr)\n\t{\n\t\tcase ACLCHECK_OK:\n\t\t\t\n\t\t\tbreak;\n\t\tcase ACLCHECK_NO_PRIV:\n\t\t\t{\n\t\t\t\tconst char *msg = \"???\";\n\n\t\t\t\tswitch (objtype)\n\t\t\t\t{\n\t\t\t\t\tcase OBJECT_AGGREGATE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for aggregate %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_COLLATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for collation %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_COLUMN:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for column %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_CONVERSION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for conversion %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_DATABASE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for database %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_DOMAIN:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for domain %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EVENT_TRIGGER:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for event trigger %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EXTENSION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for extension %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FDW:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for foreign-data wrapper %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for foreign server %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FOREIGN_TABLE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for foreign table %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FUNCTION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for function %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_INDEX:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for index %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_LANGUAGE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for language %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_LARGEOBJECT:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for large object %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_MATVIEW:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for materialized view %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPCLASS:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for operator class %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPERATOR:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for operator %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPFAMILY:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for operator family %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_POLICY:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for policy %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_PROCEDURE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for procedure %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_PUBLICATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for publication %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_ROUTINE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for routine %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SCHEMA:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for schema %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SEQUENCE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for sequence %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_STATISTIC_EXT:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for statistics object %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SUBSCRIPTION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for subscription %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TABLE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for table %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TABLESPACE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for tablespace %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TSCONFIGURATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for text search configuration %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TSDICTIONARY:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for text search dictionary %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TYPE:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for type %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_VIEW:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for view %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\t\t\t\tmsg = gettext_noop(\"permission denied for external protocol %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase OBJECT_ACCESS_METHOD:\n\t\t\t\t\tcase OBJECT_AMOP:\n\t\t\t\t\tcase OBJECT_AMPROC:\n\t\t\t\t\tcase OBJECT_ATTRIBUTE:\n\t\t\t\t\tcase OBJECT_CAST:\n\t\t\t\t\tcase OBJECT_DEFAULT:\n\t\t\t\t\tcase OBJECT_DEFACL:\n\t\t\t\t\tcase OBJECT_DOMCONSTRAINT:\n\t\t\t\t\tcase OBJECT_PUBLICATION_REL:\n\t\t\t\t\tcase OBJECT_RESGROUP:\n\t\t\t\t\tcase OBJECT_RESQUEUE:\n\t\t\t\t\tcase OBJECT_ROLE:\n\t\t\t\t\tcase OBJECT_RULE:\n\t\t\t\t\tcase OBJECT_TABCONSTRAINT:\n\t\t\t\t\tcase OBJECT_TRANSFORM:\n\t\t\t\t\tcase OBJECT_TRIGGER:\n\t\t\t\t\tcase OBJECT_TSPARSER:\n\t\t\t\t\tcase OBJECT_TSTEMPLATE:\n\t\t\t\t\tcase OBJECT_USER_MAPPING:\n\t\t\t\t\t\telog(ERROR, \"unsupported object type %d\", objtype);\n\t\t\t\t}\n\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(msg, objectname)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase ACLCHECK_NOT_OWNER:\n\t\t\t{\n\t\t\t\tconst char *msg = \"???\";\n\n\t\t\t\tswitch (objtype)\n\t\t\t\t{\n\t\t\t\t\tcase OBJECT_AGGREGATE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of aggregate %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_COLLATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of collation %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_CONVERSION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of conversion %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_DATABASE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of database %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_DOMAIN:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of domain %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EVENT_TRIGGER:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of event trigger %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EXTENSION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of extension %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FDW:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of foreign-data wrapper %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of foreign server %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FOREIGN_TABLE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of foreign table %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_FUNCTION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of function %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_INDEX:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of index %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_LANGUAGE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of language %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_LARGEOBJECT:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of large object %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_MATVIEW:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of materialized view %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPCLASS:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of operator class %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPERATOR:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of operator %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_OPFAMILY:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of operator family %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_PROCEDURE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of procedure %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_PUBLICATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of publication %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_ROUTINE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of routine %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SEQUENCE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of sequence %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SUBSCRIPTION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of subscription %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TABLE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of table %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TYPE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of type %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_VIEW:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of view %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_SCHEMA:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of schema %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_STATISTIC_EXT:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of statistics object %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TABLESPACE:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of tablespace %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TSCONFIGURATION:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of text search configuration %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_TSDICTIONARY:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of text search dictionary %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of external protocol %s\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\n\t\t\t\t\tcase OBJECT_COLUMN:\n\t\t\t\t\tcase OBJECT_POLICY:\n\t\t\t\t\tcase OBJECT_RULE:\n\t\t\t\t\tcase OBJECT_TABCONSTRAINT:\n\t\t\t\t\tcase OBJECT_TRIGGER:\n\t\t\t\t\t\tmsg = gettext_noop(\"must be owner of relation %s\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase OBJECT_ACCESS_METHOD:\n\t\t\t\t\tcase OBJECT_AMOP:\n\t\t\t\t\tcase OBJECT_AMPROC:\n\t\t\t\t\tcase OBJECT_ATTRIBUTE:\n\t\t\t\t\tcase OBJECT_CAST:\n\t\t\t\t\tcase OBJECT_DEFAULT:\n\t\t\t\t\tcase OBJECT_DEFACL:\n\t\t\t\t\tcase OBJECT_DOMCONSTRAINT:\n\t\t\t\t\tcase OBJECT_PUBLICATION_REL:\n\t\t\t\t\tcase OBJECT_RESGROUP:\n\t\t\t\t\tcase OBJECT_RESQUEUE:\n\t\t\t\t\tcase OBJECT_ROLE:\n\t\t\t\t\tcase OBJECT_TRANSFORM:\n\t\t\t\t\tcase OBJECT_TSPARSER:\n\t\t\t\t\tcase OBJECT_TSTEMPLATE:\n\t\t\t\t\tcase OBJECT_USER_MAPPING:\n\t\t\t\t\t\telog(ERROR, \"unsupported object type %d\", objtype);\n\t\t\t\t}\n\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(msg, objectname)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized AclResult: %d\", (int) aclerr);\n\t\t\tbreak;\n\t}\n}\n\n\nvoid\naclcheck_error_col(AclResult aclerr, ObjectType objtype,\n\t\t\t\t   const char *objectname, const char *colname)\n{\n\tswitch (aclerr)\n\t{\n\t\tcase ACLCHECK_OK:\n\t\t\t\n\t\t\tbreak;\n\t\tcase ACLCHECK_NO_PRIV:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"permission denied for column \\\"%s\\\" of relation \\\"%s\\\"\",\n\t\t\t\t\t\t\tcolname, objectname)));\n\t\t\tbreak;\n\t\tcase ACLCHECK_NOT_OWNER:\n\t\t\t\n\t\t\taclcheck_error(aclerr, objtype, objectname);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized AclResult: %d\", (int) aclerr);\n\t\t\tbreak;\n\t}\n}\n\n\n\nvoid\naclcheck_error_type(AclResult aclerr, Oid typeOid)\n{\n\tOid\t\t\telement_type = get_element_type(typeOid);\n\n\taclcheck_error(aclerr, OBJECT_TYPE, format_type_be(element_type ? element_type : typeOid));\n}\n\n\n\nstatic AclMode\npg_aclmask(ObjectType objtype, Oid table_oid, AttrNumber attnum, Oid roleid,\n\t\t   AclMode mask, AclMaskHow how)\n{\n\tswitch (objtype)\n\t{\n\t\tcase OBJECT_COLUMN:\n\t\t\treturn\n\t\t\t\tpg_class_aclmask(table_oid, roleid, mask, how) |\n\t\t\t\tpg_attribute_aclmask(table_oid, attnum, roleid, mask, how);\n\t\tcase OBJECT_TABLE:\n\t\tcase OBJECT_SEQUENCE:\n\t\t\treturn pg_class_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_DATABASE:\n\t\t\treturn pg_database_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_FUNCTION:\n\t\t\treturn pg_proc_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_LANGUAGE:\n\t\t\treturn pg_language_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_LARGEOBJECT:\n\t\t\treturn pg_largeobject_aclmask_snapshot(table_oid, roleid,\n\t\t\t\t\t\t\t\t\t\t\t\t   mask, how, NULL);\n\t\tcase OBJECT_SCHEMA:\n\t\t\treturn pg_namespace_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_STATISTIC_EXT:\n\t\t\telog(ERROR, \"grantable rights not supported for statistics objects\");\n\t\t\t\n\t\t\treturn ACL_NO_RIGHTS;\n\t\tcase OBJECT_TABLESPACE:\n\t\t\treturn pg_tablespace_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_FDW:\n\t\t\treturn pg_foreign_data_wrapper_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_FOREIGN_SERVER:\n\t\t\treturn pg_foreign_server_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_EVENT_TRIGGER:\n\t\t\telog(ERROR, \"grantable rights not supported for event triggers\");\n\t\t\t\n\t\t\treturn ACL_NO_RIGHTS;\n\t\tcase OBJECT_TYPE:\n\t\t\treturn pg_type_aclmask(table_oid, roleid, mask, how);\n\t\tcase OBJECT_EXTPROTOCOL:\n\t\t\treturn pg_extprotocol_aclmask(table_oid, roleid, mask, how);\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized objtype: %d\",\n\t\t\t\t (int) objtype);\n\t\t\t\n\t\t\treturn ACL_NO_RIGHTS;\n\t}\n}\n\n\n\n\n\nAclMode\npg_attribute_aclmask(Oid table_oid, AttrNumber attnum, Oid roleid,\n\t\t\t\t\t AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\tclassTuple;\n\tHeapTuple\tattTuple;\n\tForm_pg_class classForm;\n\tForm_pg_attribute attributeForm;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tattTuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t   ObjectIdGetDatum(table_oid),\n\t\t\t\t\t\t\t   Int16GetDatum(attnum));\n\tif (!HeapTupleIsValid(attTuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"attribute %d of relation with OID %u does not exist\",\n\t\t\t\t\t\tattnum, table_oid)));\n\tattributeForm = (Form_pg_attribute) GETSTRUCT(attTuple);\n\n\t\n\tif (attributeForm->attisdropped)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"attribute %d of relation with OID %u does not exist\",\n\t\t\t\t\t\tattnum, table_oid)));\n\n\taclDatum = SysCacheGetAttr(ATTNUM, attTuple, Anum_pg_attribute_attacl,\n\t\t\t\t\t\t\t   &isNull);\n\n\t\n\tif (isNull)\n\t{\n\t\tReleaseSysCache(attTuple);\n\t\treturn 0;\n\t}\n\n\t\n\tclassTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(table_oid));\n\tif (!HeapTupleIsValid(classTuple))\n\t{\n\t\tReleaseSysCache(attTuple);\n\t\treturn 0;\n\t}\n\tclassForm = (Form_pg_class) GETSTRUCT(classTuple);\n\n\townerId = classForm->relowner;\n\n\tReleaseSysCache(classTuple);\n\n\t\n\tacl = DatumGetAclP(aclDatum);\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(attTuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_class_aclmask(Oid table_oid, Oid roleid,\n\t\t\t\t AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tForm_pg_class classForm;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(table_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_TABLE),\n\t\t\t\t errmsg(\"relation with OID %u does not exist\",\n\t\t\t\t\t\ttable_oid)));\n\tclassForm = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\n\tif ((mask & (ACL_INSERT | ACL_UPDATE | ACL_DELETE | ACL_TRUNCATE | ACL_USAGE)) &&\n\t\tIsSystemClass(table_oid, classForm) &&\n\t\tclassForm->relkind != RELKIND_VIEW &&\n\t\t!superuser_arg(roleid) &&\n\t\t!allowSystemTableMods)\n\t{\n\n\t\telog(DEBUG2, \"permission denied for system catalog update\");\n\n\t\tmask &= ~(ACL_INSERT | ACL_UPDATE | ACL_DELETE | ACL_TRUNCATE | ACL_USAGE);\n\t}\n\n\t\n\tif (superuser_arg(roleid))\n\t{\n\n\t\telog(DEBUG2, \"OID %u is superuser, home free\", roleid);\n\n\t\tReleaseSysCache(tuple);\n\t\treturn mask;\n\t}\n\n\t\n\townerId = classForm->relowner;\n\n\taclDatum = SysCacheGetAttr(RELOID, tuple, Anum_pg_class_relacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tswitch (classForm->relkind)\n\t\t{\n\t\t\tcase RELKIND_SEQUENCE:\n\t\t\t\tacl = acldefault(OBJECT_SEQUENCE, ownerId);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tacl = acldefault(OBJECT_TABLE, ownerId);\n\t\t\t\tbreak;\n\t\t}\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_database_aclmask(Oid db_oid, Oid roleid,\n\t\t\t\t\tAclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(db_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database with OID %u does not exist\", db_oid)));\n\n\townerId = ((Form_pg_database) GETSTRUCT(tuple))->datdba;\n\n\taclDatum = SysCacheGetAttr(DATABASEOID, tuple, Anum_pg_database_datacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_DATABASE, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_proc_aclmask(Oid proc_oid, Oid roleid,\n\t\t\t\tAclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(proc_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function with OID %u does not exist\", proc_oid)));\n\n\townerId = ((Form_pg_proc) GETSTRUCT(tuple))->proowner;\n\n\taclDatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_proacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_FUNCTION, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_language_aclmask(Oid lang_oid, Oid roleid,\n\t\t\t\t\tAclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(lang_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"language with OID %u does not exist\", lang_oid)));\n\n\townerId = ((Form_pg_language) GETSTRUCT(tuple))->lanowner;\n\n\taclDatum = SysCacheGetAttr(LANGOID, tuple, Anum_pg_language_lanacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_LANGUAGE, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_largeobject_aclmask_snapshot(Oid lobj_oid, Oid roleid,\n\t\t\t\t\t\t\t\tAclMode mask, AclMaskHow how,\n\t\t\t\t\t\t\t\tSnapshot snapshot)\n{\n\tAclMode\t\tresult;\n\tRelation\tpg_lo_meta;\n\tScanKeyData entry[1];\n\tSysScanDesc scan;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\tpg_lo_meta = table_open(LargeObjectMetadataRelationId,\n\t\t\t\t\t\t\tAccessShareLock);\n\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_largeobject_metadata_oid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(lobj_oid));\n\n\tscan = systable_beginscan(pg_lo_meta,\n\t\t\t\t\t\t\t  LargeObjectMetadataOidIndexId, true,\n\t\t\t\t\t\t\t  snapshot, 1, entry);\n\n\ttuple = systable_getnext(scan);\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"large object %u does not exist\", lobj_oid)));\n\n\townerId = ((Form_pg_largeobject_metadata) GETSTRUCT(tuple))->lomowner;\n\n\taclDatum = heap_getattr(tuple, Anum_pg_largeobject_metadata_lomacl,\n\t\t\t\t\t\t\tRelationGetDescr(pg_lo_meta), &isNull);\n\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_LARGEOBJECT, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tsystable_endscan(scan);\n\n\ttable_close(pg_lo_meta, AccessShareLock);\n\n\treturn result;\n}\n\n\nAclMode\npg_namespace_aclmask(Oid nsp_oid, Oid roleid,\n\t\t\t\t\t AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\tif (isTempNamespace(nsp_oid))\n\t{\n\t\tif (pg_database_aclcheck(MyDatabaseId, roleid,\n\t\t\t\t\t\t\t\t ACL_CREATE_TEMP) == ACLCHECK_OK)\n\t\t\treturn mask & ACL_ALL_RIGHTS_SCHEMA;\n\t\telse\n\t\t\treturn mask & ACL_USAGE;\n\t}\n\n\t\n\ttuple = SearchSysCache1(NAMESPACEOID, ObjectIdGetDatum(nsp_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_SCHEMA),\n\t\t\t\t errmsg(\"schema with OID %u does not exist\", nsp_oid)));\n\n\townerId = ((Form_pg_namespace) GETSTRUCT(tuple))->nspowner;\n\n\taclDatum = SysCacheGetAttr(NAMESPACEOID, tuple, Anum_pg_namespace_nspacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_SCHEMA, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_tablespace_aclmask(Oid spc_oid, Oid roleid,\n\t\t\t\t\t  AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(TABLESPACEOID, ObjectIdGetDatum(spc_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"tablespace with OID %u does not exist\", spc_oid)));\n\n\townerId = ((Form_pg_tablespace) GETSTRUCT(tuple))->spcowner;\n\n\taclDatum = SysCacheGetAttr(TABLESPACEOID, tuple,\n\t\t\t\t\t\t\t   Anum_pg_tablespace_spcacl,\n\t\t\t\t\t\t\t   &isNull);\n\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_TABLESPACE, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_foreign_data_wrapper_aclmask(Oid fdw_oid, Oid roleid,\n\t\t\t\t\t\t\t\tAclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\tForm_pg_foreign_data_wrapper fdwForm;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(FOREIGNDATAWRAPPEROID, ObjectIdGetDatum(fdw_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"foreign-data wrapper with OID %u does not exist\",\n\t\t\t\t\t\tfdw_oid)));\n\tfdwForm = (Form_pg_foreign_data_wrapper) GETSTRUCT(tuple);\n\n\t\n\townerId = fdwForm->fdwowner;\n\n\taclDatum = SysCacheGetAttr(FOREIGNDATAWRAPPEROID, tuple,\n\t\t\t\t\t\t\t   Anum_pg_foreign_data_wrapper_fdwacl, &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_FDW, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_foreign_server_aclmask(Oid srv_oid, Oid roleid,\n\t\t\t\t\t\t  AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\tForm_pg_foreign_server srvForm;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(FOREIGNSERVEROID, ObjectIdGetDatum(srv_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"foreign server with OID %u does not exist\",\n\t\t\t\t\t\tsrv_oid)));\n\tsrvForm = (Form_pg_foreign_server) GETSTRUCT(tuple);\n\n\t\n\townerId = srvForm->srvowner;\n\n\taclDatum = SysCacheGetAttr(FOREIGNSERVEROID, tuple,\n\t\t\t\t\t\t\t   Anum_pg_foreign_server_srvacl, &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_FOREIGN_SERVER, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_type_aclmask(Oid type_oid, Oid roleid, AclMode mask, AclMaskHow how)\n{\n\tAclMode\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tOid\t\t\townerId;\n\n\tForm_pg_type typeForm;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn mask;\n\n\t\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type with OID %u does not exist\",\n\t\t\t\t\t\ttype_oid)));\n\ttypeForm = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\n\tif (OidIsValid(typeForm->typelem) && typeForm->typlen == -1)\n\t{\n\t\tOid\t\t\telttype_oid = typeForm->typelem;\n\n\t\tReleaseSysCache(tuple);\n\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(elttype_oid));\n\t\t\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", elttype_oid);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(tuple);\n\t}\n\n\t\n\townerId = typeForm->typowner;\n\n\taclDatum = SysCacheGetAttr(TYPEOID, tuple,\n\t\t\t\t\t\t\t   Anum_pg_type_typacl, &isNull);\n\tif (isNull)\n\t{\n\t\t\n\t\tacl = acldefault(OBJECT_TYPE, ownerId);\n\t\taclDatum = (Datum) 0;\n\t}\n\telse\n\t{\n\t\t\n\t\tacl = DatumGetAclP(aclDatum);\n\t}\n\n\tresult = aclmask(acl, roleid, ownerId, mask, how);\n\n\t\n\tif (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n\t\tpfree(acl);\n\n\tReleaseSysCache(tuple);\n\n\treturn result;\n}\n\n\nAclMode\npg_extprotocol_aclmask(Oid ptcOid, Oid roleid,\n                       AclMode mask, AclMaskHow how)\n{\n    AclMode\t\tresult;\n    HeapTuple\ttuple;\n    Datum\t\taclDatum;\n    Datum\t\townerDatum;\n    bool\t\tisNull;\n    Acl\t\t   *acl;\n    Oid\t\t\townerId;\n    Relation\trel;\n    ScanKeyData scankey;\n    SysScanDesc sscan;\n\n    \n    if (superuser_arg(roleid))\n        return mask;\n\n    rel = heap_open(ExtprotocolRelationId, AccessShareLock);\n\n    ScanKeyInit(&scankey, Anum_pg_extprotocol_oid,\n                BTEqualStrategyNumber, F_OIDEQ,\n                ObjectIdGetDatum(ptcOid));\n    sscan = systable_beginscan(rel, ExtprotocolOidIndexId, true,\n                               NULL, 1, &scankey);\n    tuple = systable_getnext(sscan);\n\n    \n    if (!HeapTupleIsValid(tuple))\n        elog(ERROR, \"protocol %u could not be found\", ptcOid);\n\n    ownerDatum = heap_getattr(tuple,\n                              Anum_pg_extprotocol_ptcowner,\n                              RelationGetDescr(rel),\n                              &isNull);\n\n    if(isNull)\n        ereport(ERROR,\n                (errcode(ERRCODE_UNDEFINED_OBJECT),\n                        errmsg(\"got invalid extprotocol owner value: NULL\")));\n\n    ownerId = DatumGetObjectId(ownerDatum);\n\n    aclDatum = heap_getattr(tuple,\n                            Anum_pg_extprotocol_ptcacl,\n                            RelationGetDescr(rel),\n                            &isNull);\n\n    if (isNull)\n    {\n        \n        acl = acldefault(OBJECT_EXTPROTOCOL, ownerId);\n        aclDatum = (Datum) 0;\n    }\n    else\n    {\n        \n        acl = DatumGetAclP(aclDatum);\n    }\n\n    result = aclmask(acl, roleid, ownerId, mask, how);\n\n    \n    if (acl && (Pointer) acl != DatumGetPointer(aclDatum))\n        pfree(acl);\n\n    \n    systable_endscan(sscan);\n    heap_close(rel, AccessShareLock);\n\n    return result;\n}\n\n\nAclResult\npg_attribute_aclcheck(Oid table_oid, AttrNumber attnum,\n\t\t\t\t\t  Oid roleid, AclMode mode)\n{\n\tif (pg_attribute_aclmask(table_oid, attnum, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_attribute_aclcheck_all(Oid table_oid, Oid roleid, AclMode mode,\n\t\t\t\t\t\t  AclMaskHow how)\n{\n\tAclResult\tresult;\n\tHeapTuple\tclassTuple;\n\tForm_pg_class classForm;\n\tAttrNumber\tnattrs;\n\tAttrNumber\tcurr_att;\n\n\t\n\tclassTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(table_oid));\n\tif (!HeapTupleIsValid(classTuple))\n\t\treturn ACLCHECK_NO_PRIV;\n\tclassForm = (Form_pg_class) GETSTRUCT(classTuple);\n\n\tnattrs = classForm->relnatts;\n\n\tReleaseSysCache(classTuple);\n\n\t\n\tresult = ACLCHECK_NO_PRIV;\n\n\tfor (curr_att = 1; curr_att <= nattrs; curr_att++)\n\t{\n\t\tHeapTuple\tattTuple;\n\t\tAclMode\t\tattmask;\n\n\t\tattTuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(table_oid),\n\t\t\t\t\t\t\t\t   Int16GetDatum(curr_att));\n\t\tif (!HeapTupleIsValid(attTuple))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (((Form_pg_attribute) GETSTRUCT(attTuple))->attisdropped)\n\t\t{\n\t\t\tReleaseSysCache(attTuple);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (heap_attisnull(attTuple, Anum_pg_attribute_attacl, NULL))\n\t\t\tattmask = 0;\n\t\telse\n\t\t\tattmask = pg_attribute_aclmask(table_oid, curr_att, roleid,\n\t\t\t\t\t\t\t\t\t\t   mode, ACLMASK_ANY);\n\n\t\tReleaseSysCache(attTuple);\n\n\t\tif (attmask != 0)\n\t\t{\n\t\t\tresult = ACLCHECK_OK;\n\t\t\tif (how == ACLMASK_ANY)\n\t\t\t\tbreak;\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = ACLCHECK_NO_PRIV;\n\t\t\tif (how == ACLMASK_ALL)\n\t\t\t\tbreak;\t\t\t\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\nAclResult\npg_class_aclcheck(Oid table_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_class_aclmask(table_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_database_aclcheck(Oid db_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_database_aclmask(db_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_proc_aclcheck(Oid proc_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_proc_aclmask(proc_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_language_aclcheck(Oid lang_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_language_aclmask(lang_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_largeobject_aclcheck_snapshot(Oid lobj_oid, Oid roleid, AclMode mode,\n\t\t\t\t\t\t\t\t Snapshot snapshot)\n{\n\tif (pg_largeobject_aclmask_snapshot(lobj_oid, roleid, mode,\n\t\t\t\t\t\t\t\t\t\tACLMASK_ANY, snapshot) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_namespace_aclcheck(Oid nsp_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_namespace_aclmask(nsp_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_tablespace_aclcheck(Oid spc_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_tablespace_aclmask(spc_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_foreign_data_wrapper_aclcheck(Oid fdw_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_foreign_data_wrapper_aclmask(fdw_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_foreign_server_aclcheck(Oid srv_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_foreign_server_aclmask(srv_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_type_aclcheck(Oid type_oid, Oid roleid, AclMode mode)\n{\n\tif (pg_type_aclmask(type_oid, roleid, mode, ACLMASK_ANY) != 0)\n\t\treturn ACLCHECK_OK;\n\telse\n\t\treturn ACLCHECK_NO_PRIV;\n}\n\n\nAclResult\npg_extprotocol_aclcheck(Oid ptcid, Oid roleid, AclMode mode)\n{\n    if (pg_extprotocol_aclmask(ptcid, roleid, mode, ACLMASK_ANY) != 0)\n        return ACLCHECK_OK;\n    else\n        return ACLCHECK_NO_PRIV;\n}\n\n\nbool\npg_class_ownercheck(Oid class_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(class_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_TABLE),\n\t\t\t\t errmsg(\"relation with OID %u does not exist\", class_oid)));\n\n\townerId = ((Form_pg_class) GETSTRUCT(tuple))->relowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_type_ownercheck(Oid type_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type with OID %u does not exist\", type_oid)));\n\n\townerId = ((Form_pg_type) GETSTRUCT(tuple))->typowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_oper_ownercheck(Oid oper_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(OPEROID, ObjectIdGetDatum(oper_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator with OID %u does not exist\", oper_oid)));\n\n\townerId = ((Form_pg_operator) GETSTRUCT(tuple))->oprowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_proc_ownercheck(Oid proc_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(proc_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function with OID %u does not exist\", proc_oid)));\n\n\townerId = ((Form_pg_proc) GETSTRUCT(tuple))->proowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_language_ownercheck(Oid lan_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(lan_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"language with OID %u does not exist\", lan_oid)));\n\n\townerId = ((Form_pg_language) GETSTRUCT(tuple))->lanowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_largeobject_ownercheck(Oid lobj_oid, Oid roleid)\n{\n\tRelation\tpg_lo_meta;\n\tScanKeyData entry[1];\n\tSysScanDesc scan;\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\t\n\tpg_lo_meta = table_open(LargeObjectMetadataRelationId,\n\t\t\t\t\t\t\tAccessShareLock);\n\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_largeobject_metadata_oid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(lobj_oid));\n\n\tscan = systable_beginscan(pg_lo_meta,\n\t\t\t\t\t\t\t  LargeObjectMetadataOidIndexId, true,\n\t\t\t\t\t\t\t  NULL, 1, entry);\n\n\ttuple = systable_getnext(scan);\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"large object %u does not exist\", lobj_oid)));\n\n\townerId = ((Form_pg_largeobject_metadata) GETSTRUCT(tuple))->lomowner;\n\n\tsystable_endscan(scan);\n\ttable_close(pg_lo_meta, AccessShareLock);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_namespace_ownercheck(Oid nsp_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(NAMESPACEOID, ObjectIdGetDatum(nsp_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_SCHEMA),\n\t\t\t\t errmsg(\"schema with OID %u does not exist\", nsp_oid)));\n\n\townerId = ((Form_pg_namespace) GETSTRUCT(tuple))->nspowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_tablespace_ownercheck(Oid spc_oid, Oid roleid)\n{\n\tHeapTuple\tspctuple;\n\tOid\t\t\tspcowner;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\t\n\tspctuple = SearchSysCache1(TABLESPACEOID, ObjectIdGetDatum(spc_oid));\n\tif (!HeapTupleIsValid(spctuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"tablespace with OID %u does not exist\", spc_oid)));\n\n\tspcowner = ((Form_pg_tablespace) GETSTRUCT(spctuple))->spcowner;\n\n\tReleaseSysCache(spctuple);\n\n\treturn has_privs_of_role(roleid, spcowner);\n}\n\n\nbool\npg_opclass_ownercheck(Oid opc_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(CLAOID, ObjectIdGetDatum(opc_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"operator class with OID %u does not exist\",\n\t\t\t\t\t\topc_oid)));\n\n\townerId = ((Form_pg_opclass) GETSTRUCT(tuple))->opcowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_opfamily_ownercheck(Oid opf_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(OPFAMILYOID, ObjectIdGetDatum(opf_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"operator family with OID %u does not exist\",\n\t\t\t\t\t\topf_oid)));\n\n\townerId = ((Form_pg_opfamily) GETSTRUCT(tuple))->opfowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_ts_dict_ownercheck(Oid dict_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(TSDICTOID, ObjectIdGetDatum(dict_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"text search dictionary with OID %u does not exist\",\n\t\t\t\t\t\tdict_oid)));\n\n\townerId = ((Form_pg_ts_dict) GETSTRUCT(tuple))->dictowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_ts_config_ownercheck(Oid cfg_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(TSCONFIGOID, ObjectIdGetDatum(cfg_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"text search configuration with OID %u does not exist\",\n\t\t\t\t\t\tcfg_oid)));\n\n\townerId = ((Form_pg_ts_config) GETSTRUCT(tuple))->cfgowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_foreign_data_wrapper_ownercheck(Oid srv_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(FOREIGNDATAWRAPPEROID, ObjectIdGetDatum(srv_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"foreign-data wrapper with OID %u does not exist\",\n\t\t\t\t\t\tsrv_oid)));\n\n\townerId = ((Form_pg_foreign_data_wrapper) GETSTRUCT(tuple))->fdwowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_foreign_server_ownercheck(Oid srv_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(FOREIGNSERVEROID, ObjectIdGetDatum(srv_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"foreign server with OID %u does not exist\",\n\t\t\t\t\t\tsrv_oid)));\n\n\townerId = ((Form_pg_foreign_server) GETSTRUCT(tuple))->srvowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_event_trigger_ownercheck(Oid et_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(EVENTTRIGGEROID, ObjectIdGetDatum(et_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"event trigger with OID %u does not exist\",\n\t\t\t\t\t\tet_oid)));\n\n\townerId = ((Form_pg_event_trigger) GETSTRUCT(tuple))->evtowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_database_ownercheck(Oid db_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\tdba;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(db_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_DATABASE),\n\t\t\t\t errmsg(\"database with OID %u does not exist\", db_oid)));\n\n\tdba = ((Form_pg_database) GETSTRUCT(tuple))->datdba;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, dba);\n}\n\n\nbool\npg_collation_ownercheck(Oid coll_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(COLLOID, ObjectIdGetDatum(coll_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"collation with OID %u does not exist\", coll_oid)));\n\n\townerId = ((Form_pg_collation) GETSTRUCT(tuple))->collowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_conversion_ownercheck(Oid conv_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(CONVOID, ObjectIdGetDatum(conv_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"conversion with OID %u does not exist\", conv_oid)));\n\n\townerId = ((Form_pg_conversion) GETSTRUCT(tuple))->conowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_extension_ownercheck(Oid ext_oid, Oid roleid)\n{\n\tRelation\tpg_extension;\n\tScanKeyData entry[1];\n\tSysScanDesc scan;\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\t\n\tpg_extension = table_open(ExtensionRelationId, AccessShareLock);\n\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_extension_oid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(ext_oid));\n\n\tscan = systable_beginscan(pg_extension,\n\t\t\t\t\t\t\t  ExtensionOidIndexId, true,\n\t\t\t\t\t\t\t  NULL, 1, entry);\n\n\ttuple = systable_getnext(scan);\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"extension with OID %u does not exist\", ext_oid)));\n\n\townerId = ((Form_pg_extension) GETSTRUCT(tuple))->extowner;\n\n\tsystable_endscan(scan);\n\ttable_close(pg_extension, AccessShareLock);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_publication_ownercheck(Oid pub_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(PUBLICATIONOID, ObjectIdGetDatum(pub_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"publication with OID %u does not exist\", pub_oid)));\n\n\townerId = ((Form_pg_publication) GETSTRUCT(tuple))->pubowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_subscription_ownercheck(Oid sub_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(SUBSCRIPTIONOID, ObjectIdGetDatum(sub_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"subscription with OID %u does not exist\", sub_oid)));\n\n\townerId = ((Form_pg_subscription) GETSTRUCT(tuple))->subowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_statistics_object_ownercheck(Oid stat_oid, Oid roleid)\n{\n\tHeapTuple\ttuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\ttuple = SearchSysCache1(STATEXTOID, ObjectIdGetDatum(stat_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"statistics object with OID %u does not exist\",\n\t\t\t\t\t\tstat_oid)));\n\n\townerId = ((Form_pg_statistic_ext) GETSTRUCT(tuple))->stxowner;\n\n\tReleaseSysCache(tuple);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\npg_extprotocol_ownercheck(Oid protOid, Oid roleid)\n{\n\tRelation\tpg_extprotocol;\n\tScanKeyData entry[1];\n\tSysScanDesc scan;\n\tHeapTuple\teptuple;\n\tOid\t\t\townerId;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\t\n\tpg_extprotocol = table_open(ExtprotocolRelationId, AccessShareLock);\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_extprotocol_oid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(protOid));\n\tscan = systable_beginscan(pg_extprotocol, ExtprotocolOidIndexId, true,\n\t\t\t\t\t\t\t  NULL, 1, entry);\n\n\teptuple = systable_getnext(scan);\n\n\tif (!HeapTupleIsValid(eptuple))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"external protocol with OID %u does not exist\", protOid)));\n\n\townerId = ((Form_pg_extprotocol) GETSTRUCT(eptuple))->ptcowner;\n\n\tsystable_endscan(scan);\n\ttable_close(pg_extprotocol, AccessShareLock);\n\n\treturn has_privs_of_role(roleid, ownerId);\n}\n\n\nbool\nhas_createrole_privilege(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolcreaterole;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}\n\nbool\nhas_bypassrls_privilege(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\t\n\tif (superuser_arg(roleid))\n\t\treturn true;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolbypassrls;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}\n\n\nstatic Acl *\nget_default_acl_internal(Oid roleId, Oid nsp_oid, char objtype)\n{\n\tAcl\t\t   *result = NULL;\n\tHeapTuple\ttuple;\n\n\ttuple = SearchSysCache3(DEFACLROLENSPOBJ,\n\t\t\t\t\t\t\tObjectIdGetDatum(roleId),\n\t\t\t\t\t\t\tObjectIdGetDatum(nsp_oid),\n\t\t\t\t\t\t\tCharGetDatum(objtype));\n\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\n\t\taclDatum = SysCacheGetAttr(DEFACLROLENSPOBJ, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_default_acl_defaclacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (!isNull)\n\t\t\tresult = DatumGetAclPCopy(aclDatum);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\treturn result;\n}\n\n\nAcl *\nget_user_default_acl(ObjectType objtype, Oid ownerId, Oid nsp_oid)\n{\n\tAcl\t\t   *result;\n\tAcl\t\t   *glob_acl;\n\tAcl\t\t   *schema_acl;\n\tAcl\t\t   *def_acl;\n\tchar\t\tdefaclobjtype;\n\n\t\n\tif (IsBootstrapProcessingMode())\n\t\treturn NULL;\n\n\t\n\tswitch (objtype)\n\t{\n\t\tcase OBJECT_TABLE:\n\t\t\tdefaclobjtype = DEFACLOBJ_RELATION;\n\t\t\tbreak;\n\n\t\tcase OBJECT_SEQUENCE:\n\t\t\tdefaclobjtype = DEFACLOBJ_SEQUENCE;\n\t\t\tbreak;\n\n\t\tcase OBJECT_FUNCTION:\n\t\t\tdefaclobjtype = DEFACLOBJ_FUNCTION;\n\t\t\tbreak;\n\n\t\tcase OBJECT_TYPE:\n\t\t\tdefaclobjtype = DEFACLOBJ_TYPE;\n\t\t\tbreak;\n\n\t\tcase OBJECT_SCHEMA:\n\t\t\tdefaclobjtype = DEFACLOBJ_NAMESPACE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\n\t\n\tglob_acl = get_default_acl_internal(ownerId, InvalidOid, defaclobjtype);\n\tschema_acl = get_default_acl_internal(ownerId, nsp_oid, defaclobjtype);\n\n\t\n\tif (glob_acl == NULL && schema_acl == NULL)\n\t\treturn NULL;\n\n\t\n\tdef_acl = acldefault(objtype, ownerId);\n\n\t\n\tif (glob_acl == NULL)\n\t\tglob_acl = def_acl;\n\n\t\n\tresult = aclmerge(glob_acl, schema_acl, ownerId);\n\n\t\n\taclitemsort(result);\n\taclitemsort(def_acl);\n\tif (aclequal(result, def_acl))\n\t\tresult = NULL;\n\n\treturn result;\n}\n\n\nvoid\nrecordDependencyOnNewAcl(Oid classId, Oid objectId, int32 objsubId,\n\t\t\t\t\t\t Oid ownerId, Acl *acl)\n{\n\tint\t\t\tnmembers;\n\tOid\t\t   *members;\n\n\t\n\tif (acl == NULL)\n\t\treturn;\n\n\t\n\tnmembers = aclmembers(acl, &members);\n\n\t\n\tupdateAclDependencies(classId, objectId, objsubId,\n\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t  0, NULL,\n\t\t\t\t\t\t  nmembers, members);\n}\n\n\nvoid\nrecordExtObjInitPriv(Oid objoid, Oid classoid)\n{\n\t\n\tif (classoid == RelationRelationId)\n\t{\n\t\tForm_pg_class pg_class_tuple;\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", objoid);\n\t\tpg_class_tuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_INDEX ||\n\t\t\tpg_class_tuple->relkind == RELKIND_PARTITIONED_INDEX)\n\t\t\treturn;\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_COMPOSITE_TYPE)\n\t\t\treturn;\n\n\t\t\n\t\tif (pg_class_tuple->relkind != RELKIND_SEQUENCE)\n\t\t{\n\t\t\tAttrNumber\tcurr_att;\n\t\t\tAttrNumber\tnattrs = pg_class_tuple->relnatts;\n\n\t\t\tfor (curr_att = 1; curr_att <= nattrs; curr_att++)\n\t\t\t{\n\t\t\t\tHeapTuple\tattTuple;\n\t\t\t\tDatum\t\tattaclDatum;\n\n\t\t\t\tattTuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(objoid),\n\t\t\t\t\t\t\t\t\t\t   Int16GetDatum(curr_att));\n\n\t\t\t\tif (!HeapTupleIsValid(attTuple))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t\n\t\t\t\tif (((Form_pg_attribute) GETSTRUCT(attTuple))->attisdropped)\n\t\t\t\t{\n\t\t\t\t\tReleaseSysCache(attTuple);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tattaclDatum = SysCacheGetAttr(ATTNUM, attTuple,\n\t\t\t\t\t\t\t\t\t\t\t  Anum_pg_attribute_attacl,\n\t\t\t\t\t\t\t\t\t\t\t  &isNull);\n\n\t\t\t\t\n\t\t\t\tif (isNull)\n\t\t\t\t{\n\t\t\t\t\tReleaseSysCache(attTuple);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trecordExtensionInitPrivWorker(objoid, classoid, curr_att,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(attaclDatum));\n\n\t\t\t\tReleaseSysCache(attTuple);\n\t\t\t}\n\t\t}\n\n\t\taclDatum = SysCacheGetAttr(RELOID, tuple, Anum_pg_class_relacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == ForeignDataWrapperRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(FOREIGNDATAWRAPPEROID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for foreign data wrapper %u\",\n\t\t\t\t objoid);\n\n\t\taclDatum = SysCacheGetAttr(FOREIGNDATAWRAPPEROID, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_foreign_data_wrapper_fdwacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == ForeignServerRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(FOREIGNSERVEROID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for foreign data wrapper %u\",\n\t\t\t\t objoid);\n\n\t\taclDatum = SysCacheGetAttr(FOREIGNSERVEROID, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_foreign_server_srvacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == LanguageRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for language %u\", objoid);\n\n\t\taclDatum = SysCacheGetAttr(LANGOID, tuple, Anum_pg_language_lanacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == LargeObjectMetadataRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\t\tScanKeyData entry[1];\n\t\tSysScanDesc scan;\n\t\tRelation\trelation;\n\n\t\trelation = table_open(LargeObjectMetadataRelationId, RowExclusiveLock);\n\n\t\t\n\t\tScanKeyInit(&entry[0],\n\t\t\t\t\tAnum_pg_largeobject_metadata_oid,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(objoid));\n\n\t\tscan = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t  LargeObjectMetadataOidIndexId, true,\n\t\t\t\t\t\t\t\t  NULL, 1, entry);\n\n\t\ttuple = systable_getnext(scan);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"could not find tuple for large object %u\", objoid);\n\n\t\taclDatum = heap_getattr(tuple,\n\t\t\t\t\t\t\t\tAnum_pg_largeobject_metadata_lomacl,\n\t\t\t\t\t\t\t\tRelationGetDescr(relation), &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tsystable_endscan(scan);\n\t}\n\t\n\telse if (classoid == NamespaceRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(NAMESPACEOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\", objoid);\n\n\t\taclDatum = SysCacheGetAttr(NAMESPACEOID, tuple,\n\t\t\t\t\t\t\t\t   Anum_pg_namespace_nspacl, &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == ProcedureRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\", objoid);\n\n\t\taclDatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_proacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\t\n\telse if (classoid == TypeRelationId)\n\t{\n\t\tDatum\t\taclDatum;\n\t\tbool\t\tisNull;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\", objoid);\n\n\t\taclDatum = SysCacheGetAttr(TYPEOID, tuple, Anum_pg_type_typacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\n\t\t\n\t\tif (!isNull)\n\t\t\trecordExtensionInitPrivWorker(objoid, classoid, 0,\n\t\t\t\t\t\t\t\t\t\t  DatumGetAclP(aclDatum));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse if (classoid == AccessMethodRelationId ||\n\t\t\t classoid == AggregateRelationId ||\n\t\t\t classoid == CastRelationId ||\n\t\t\t classoid == CollationRelationId ||\n\t\t\t classoid == ConversionRelationId ||\n\t\t\t classoid == EventTriggerRelationId ||\n\t\t\t classoid == OperatorRelationId ||\n\t\t\t classoid == OperatorClassRelationId ||\n\t\t\t classoid == OperatorFamilyRelationId ||\n\t\t\t classoid == NamespaceRelationId ||\n\t\t\t classoid == TSConfigRelationId ||\n\t\t\t classoid == TSDictionaryRelationId ||\n\t\t\t classoid == TSParserRelationId ||\n\t\t\t classoid == TSTemplateRelationId ||\n\t\t\t classoid == TransformRelationId\n\t\t)\n\t{\n\t\t\n\t}\n\n\t\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized or unsupported class OID: %u\", classoid);\n\t}\n}\n\n\nvoid\nremoveExtObjInitPriv(Oid objoid, Oid classoid)\n{\n\t\n\tif (classoid == RelationRelationId)\n\t{\n\t\tForm_pg_class pg_class_tuple;\n\t\tHeapTuple\ttuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(objoid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", objoid);\n\t\tpg_class_tuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_INDEX ||\n\t\t\tpg_class_tuple->relkind == RELKIND_PARTITIONED_INDEX)\n\t\t\treturn;\n\n\t\t\n\t\tif (pg_class_tuple->relkind == RELKIND_COMPOSITE_TYPE)\n\t\t\treturn;\n\n\t\t\n\t\tif (pg_class_tuple->relkind != RELKIND_SEQUENCE)\n\t\t{\n\t\t\tAttrNumber\tcurr_att;\n\t\t\tAttrNumber\tnattrs = pg_class_tuple->relnatts;\n\n\t\t\tfor (curr_att = 1; curr_att <= nattrs; curr_att++)\n\t\t\t{\n\t\t\t\tHeapTuple\tattTuple;\n\n\t\t\t\tattTuple = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(objoid),\n\t\t\t\t\t\t\t\t\t\t   Int16GetDatum(curr_att));\n\n\t\t\t\tif (!HeapTupleIsValid(attTuple))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t\n\n\t\t\t\trecordExtensionInitPrivWorker(objoid, classoid, curr_att, NULL);\n\n\t\t\t\tReleaseSysCache(attTuple);\n\t\t\t}\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t\n\trecordExtensionInitPrivWorker(objoid, classoid, 0, NULL);\n}\n\n\nstatic void\nrecordExtensionInitPriv(Oid objoid, Oid classoid, int objsubid, Acl *new_acl)\n{\n\t\n\tif (!creating_extension && !binary_upgrade_record_init_privs)\n\t\treturn;\n\n\trecordExtensionInitPrivWorker(objoid, classoid, objsubid, new_acl);\n}\n\n\nstatic void\nrecordExtensionInitPrivWorker(Oid objoid, Oid classoid, int objsubid, Acl *new_acl)\n{\n\tRelation\trelation;\n\tScanKeyData key[3];\n\tSysScanDesc scan;\n\tHeapTuple\ttuple;\n\tHeapTuple\toldtuple;\n\n\trelation = table_open(InitPrivsRelationId, RowExclusiveLock);\n\n\tScanKeyInit(&key[0],\n\t\t\t\tAnum_pg_init_privs_objoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(objoid));\n\tScanKeyInit(&key[1],\n\t\t\t\tAnum_pg_init_privs_classoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(classoid));\n\tScanKeyInit(&key[2],\n\t\t\t\tAnum_pg_init_privs_objsubid,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\tInt32GetDatum(objsubid));\n\n\tscan = systable_beginscan(relation, InitPrivsObjIndexId, true,\n\t\t\t\t\t\t\t  NULL, 3, key);\n\n\t\n\toldtuple = systable_getnext(scan);\n\n\t\n\tif (HeapTupleIsValid(oldtuple))\n\t{\n\t\tDatum\t\tvalues[Natts_pg_init_privs];\n\t\tbool\t\tnulls[Natts_pg_init_privs];\n\t\tbool\t\treplace[Natts_pg_init_privs];\n\n\t\t\n\t\tif (new_acl)\n\t\t{\n\t\t\tMemSet(values, 0, sizeof(values));\n\t\t\tMemSet(nulls, false, sizeof(nulls));\n\t\t\tMemSet(replace, false, sizeof(replace));\n\n\t\t\tvalues[Anum_pg_init_privs_initprivs - 1] = PointerGetDatum(new_acl);\n\t\t\treplace[Anum_pg_init_privs_initprivs - 1] = true;\n\n\t\t\toldtuple = heap_modify_tuple(oldtuple, RelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t\t values, nulls, replace);\n\n\t\t\tCatalogTupleUpdate(relation, &oldtuple->t_self, oldtuple);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tCatalogTupleDelete(relation, &oldtuple->t_self);\n\t\t}\n\t}\n\telse\n\t{\n\t\tDatum\t\tvalues[Natts_pg_init_privs];\n\t\tbool\t\tnulls[Natts_pg_init_privs];\n\n\t\t\n\t\tif (new_acl)\n\t\t{\n\t\t\t\n\t\t\tMemSet(nulls, false, sizeof(nulls));\n\n\t\t\tvalues[Anum_pg_init_privs_objoid - 1] = ObjectIdGetDatum(objoid);\n\t\t\tvalues[Anum_pg_init_privs_classoid - 1] = ObjectIdGetDatum(classoid);\n\t\t\tvalues[Anum_pg_init_privs_objsubid - 1] = Int32GetDatum(objsubid);\n\n\t\t\t\n\t\t\tvalues[Anum_pg_init_privs_privtype - 1] =\n\t\t\t\tCharGetDatum(INITPRIVS_EXTENSION);\n\n\t\t\tvalues[Anum_pg_init_privs_initprivs - 1] = PointerGetDatum(new_acl);\n\n\t\t\ttuple = heap_form_tuple(RelationGetDescr(relation), values, nulls);\n\n\t\t\tCatalogTupleInsert(relation, tuple);\n\t\t}\n\t}\n\n\tsystable_endscan(scan);\n\n\t\n\tCommandCounterIncrement();\n\n\ttable_close(relation, RowExclusiveLock);\n}\n\n\nvoid\nCopyRelationAcls(Oid srcId, Oid destId)\n{\n\tRelation\tpg_class_rel;\n\tRelation\tpg_attribute_rel;\n\tDatum\t\taclDatum;\n\tbool\t\tisNull;\n\tAcl\t\t   *acl;\n\tForm_pg_class pg_class_tuple;\n\tHeapTuple\tsrcTuple;\n\tHeapTuple\tdestTuple;\n\tHeapTuple\tnewTuple;\n\tDatum\t\tvalues[Natts_pg_class];\n\tbool\t\tnulls[Natts_pg_class];\n\tbool\t\treplaces[Natts_pg_class];\n\tint\t\t\tnnewmembers;\n\tOid\t\t   *newmembers;\n\tOid\t\t\townerId;\n\tCatCList   *attlist;\n\tint\t\t\ti;\n\n\tpg_class_rel = heap_open(RelationRelationId, RowExclusiveLock);\n\tpg_attribute_rel = heap_open(AttributeRelationId, RowExclusiveLock);\n\n\t\n\tsrcTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(srcId));\n\tif (!HeapTupleIsValid(srcTuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", srcId);\n\taclDatum = SysCacheGetAttr(RELOID, srcTuple, Anum_pg_class_relacl,\n\t\t\t\t\t\t\t   &isNull);\n\tif (isNull)\n\t\tacl = NULL;\n\telse\n\t\tacl = DatumGetAclPCopy(aclDatum);\n\n\t\n\tdestTuple = SearchSysCache1(RELOID, ObjectIdGetDatum(destId));\n\tif (!HeapTupleIsValid(destTuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", destId);\n\tpg_class_tuple = (Form_pg_class) GETSTRUCT(destTuple);\n\n\tif (pg_class_tuple->relkind != RELKIND_RELATION &&\n\t\tpg_class_tuple->relkind != RELKIND_PARTITIONED_TABLE &&\n\t\tpg_class_tuple->relkind != RELKIND_FOREIGN_TABLE)\n\t\telog(ERROR, \"unexpected relkind %c\",  pg_class_tuple->relkind);\n\n\t\n\t(void) SysCacheGetAttr(RELOID, destTuple, Anum_pg_class_relacl,\n\t\t\t\t\t\t   &isNull);\n\tif (!isNull)\n\t\telog(ERROR, \"cannot copy ACL from parent, because there is an existing ACL\");\n\n\t\n\tMemSet(values, 0, sizeof(values));\n\tMemSet(nulls, false, sizeof(nulls));\n\tMemSet(replaces, false, sizeof(replaces));\n\n\treplaces[Anum_pg_class_relacl - 1] = true;\n\tif (acl)\n\t{\n\t\tvalues[Anum_pg_class_relacl - 1] = PointerGetDatum(acl);\n\t\tnulls[Anum_pg_class_relacl - 1] = false;\n\t}\n\telse\n\t{\n\t\tvalues[Anum_pg_class_relacl - 1] = (Datum) 0;\n\t\tnulls[Anum_pg_class_relacl - 1] = true;\n\t}\n\tnewTuple = heap_modify_tuple(destTuple, RelationGetDescr(pg_class_rel),\n\t\t\t\t\t\t\t\t values, nulls, replaces);\n\n\tCatalogTupleUpdate(pg_class_rel, &newTuple->t_self, newTuple);\n\n\t\n\townerId = pg_class_tuple->relowner;\n\tnnewmembers = aclmembers(acl, &newmembers);\n\n\tupdateAclDependencies(RelationRelationId, destId, 0,\n\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t  0, NULL,\n\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\n\tattlist = SearchSysCacheList1(ATTNUM, srcId);\n\tfor (i = 0; i < attlist->n_members; i++)\n\t{\n\t\tHeapTuple\tattSrcTuple = &attlist->members[i]->tuple;\n\t\tForm_pg_attribute attSrcForm = (Form_pg_attribute) GETSTRUCT(attSrcTuple);\n\t\tAttrNumber\tattnum = attSrcForm->attnum;\n\t\tHeapTuple\tattDestTuple;\n\t\tDatum\t\tvalues[Natts_pg_attribute];\n\t\tbool\t\tnulls[Natts_pg_attribute];\n\t\tbool\t\treplaces[Natts_pg_attribute];\n\n\t\taclDatum = SysCacheGetAttr(ATTNUM, attSrcTuple, Anum_pg_attribute_attacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (isNull)\n\t\t\tcontinue;\n\t\tacl = DatumGetAclPCopy(aclDatum);\n\n\t\tattDestTuple = SearchSysCache2(ATTNUM, destId, attnum);\n\n\t\t(void) SysCacheGetAttr(ATTNUM, attDestTuple, Anum_pg_attribute_attacl,\n\t\t\t\t\t\t\t\t   &isNull);\n\t\tif (!isNull)\n\t\t\telog(ERROR, \"cannot copy ACL from parent, because there is an existing ACL\");\n\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\t\tMemSet(replaces, false, sizeof(replaces));\n\n\t\treplaces[Anum_pg_attribute_attacl - 1] = true;\n\t\tif (acl)\n\t\t{\n\t\t\tvalues[Anum_pg_attribute_attacl - 1] = PointerGetDatum(acl);\n\t\t\tnulls[Anum_pg_attribute_attacl - 1] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[Anum_pg_attribute_attacl - 1] = (Datum) 0;\n\t\t\tnulls[Anum_pg_attribute_attacl - 1] = true;\n\t\t}\n\t\tnewTuple = heap_modify_tuple(attDestTuple, RelationGetDescr(pg_attribute_rel),\n\t\t\t\t\t\t\t\t\t values, nulls, replaces);\n\n\t\tCatalogTupleUpdate(pg_attribute_rel, &newTuple->t_self, newTuple);\n\n\t\t\n\t\townerId = pg_class_tuple->relowner;\n\t\tnnewmembers = aclmembers(acl, &newmembers);\n\n\t\tupdateAclDependencies(RelationRelationId, destId, attnum,\n\t\t\t\t\t\t\t  ownerId,\n\t\t\t\t\t\t\t  0, NULL,\n\t\t\t\t\t\t\t  nnewmembers, newmembers);\n\n\t\tReleaseSysCache(attDestTuple);\n\t}\n\tReleaseSysCacheList(attlist);\n\n\tReleaseSysCache(srcTuple);\n\tReleaseSysCache(destTuple);\n\theap_close(pg_class_rel, RowExclusiveLock);\n\theap_close(pg_attribute_rel, RowExclusiveLock);\n\n\t\n\tCommandCounterIncrement();\n}\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse elog log",
        "file_path": "src/backend/catalog/aclchk.c:142"
    },
    {
        "log": "ereport(ERROR,\n\t\t\t\t\t\t(errdetails_index_policy(NameStr(TupleDescAttr(desc, policy_attr - 1)->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t policy_opclass,\n\t\t\t\t\t\t\t\t\t\t\t\t policy_eqop,\n\t\t\t\t\t\t\t\t\t\t\t\t found_col_indclass,\n\t\t\t\t\t\t\t\t\t\t\t\t exclop,\n\t\t\t\t\t\t\t\t\t\t\t\t error_context)))",
        "severity_level": "ERROR",
        "errmsg_template": null,
        "errmsg_variables": [],
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": null,
        "file_path": "src/backend/cdb/cdbcat.c:719"
    },
    {
        "log": "ereport(DTM_DEBUG5,\n\t\t\t(errmsg(\"dispatchDtxProtocolCommand: %d ('%s'), direct content \n\t\t\t\t\tdtxProtocolCommand, dtxProtocolCommandStr,\n\t\t\t\t\tsegmentsToContentStr(dtxSegments))));\n\n\tErrorData *qeError;\n\tresults = CdbDispatchDtxProtocolCommand(dtxProtocolCommand,\n\t\t\t\t\t\t\t\t\t\t\tdtxProtocolCommandStr,\n\t\t\t\t\t\t\t\t\t\t\tgid,\n\t\t\t\t\t\t\t\t\t\t\t&qeError, &resultCount, dtxSegments,\n\t\t\t\t\t\t\t\t\t\t\tserializedDtxContextInfo, serializedDtxContextInfoLen);\n\n\tif (qeError)\n\t{\n\t\t\n\t\tereportif(Debug_print_full_dtm, LOG,\n\t\t\t\t  (errmsg(\"error on dispatch of dtx protocol command '%s' for gid '%s'\",\n\t\t\t\t\t\t  dtxProtocolCommandStr, gid),\n\t\t\t\t   errdetail(\"QE reported error: %s\", qeError->message)));\n\n\t\tif (raiseError)\n\t\t{\n\t\t\t\n\t\t\tFlushErrorState();\n\t\t\tThrowErrorData(qeError);\n\t\t}\n\t}\n\n\tif (results == NULL)\n\t{\n\t\tnumOfFailed++;\t\t\t\n\t}\n\n\tfor (i = 0; i < resultCount; i++)\n\t{\n\t\tchar\t   *cmdStatus;\n\t\tExecStatusType resultStatus;\n\n\t\t\n\t\tresultStatus = PQresultStatus(results[i]);\n\t\tif (resultStatus != PGRES_COMMAND_OK &&\n\t\t\tresultStatus != PGRES_TUPLES_OK)\n\t\t{\n\t\t\tnumOfFailed++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tcmdStatus = PQcmdStatus(results[i]);\n\n\t\t\telog(DEBUG3, \"DTM: status message cmd '%s' [%d] result '%s'\", dtxProtocolCommandStr, i, cmdStatus);\n\t\t\tif (strncmp(cmdStatus, dtxProtocolCommandStr, strlen(cmdStatus)) != 0)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tnumOfFailed++;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < resultCount; i++)\n\t\ttotalWaits += results[i]->nWaits;\n\n\tif (totalWaits > 0)\n\t\twaitGxids = palloc(sizeof(int) * totalWaits);\n\n\ttotalWaits = 0;\n\tfor (i = 0; i < resultCount; i++)\n\t{\n\t\tstruct pg_result *result = results[i];\n\n\t\tif (result->nWaits > 0)\n\t\t{\n\t\t\tmemcpy(&waitGxids[totalWaits], result->waitGxids, sizeof(int) * result->nWaits);\n\t\t\ttotalWaits += result->nWaits;\n\t\t}\n\t\tPQclear(result);\n\t}\n\n\tif (totalWaits > 0)\n\t{\n\t\tint lastRepeat = -1;\n\t\tif (MyTmGxactLocal->waitGxids)\n\t\t{\n\t\t\tlist_free(MyTmGxactLocal->waitGxids);\n\t\t\tMyTmGxactLocal->waitGxids = NULL;\n\t\t}\n\n\t\tqsort(waitGxids, totalWaits, sizeof(int), compare_int);\n\n\t\toldContext = MemoryContextSwitchTo(TopTransactionContext);\n\t\tfor (i = 0; i < totalWaits; i++)\n\t\t{\n\t\t\tif (waitGxids[i] == lastRepeat)\n\t\t\t\tcontinue;\n\t\t\tMyTmGxactLocal->waitGxids = lappend_int(MyTmGxactLocal->waitGxids, waitGxids[i]);\n\t\t\tlastRepeat = waitGxids[i];\n\t\t}\n\t\tMemoryContextSwitchTo(oldContext);\n\t}\n\n\tif (waitGxids)\n\t\tpfree(waitGxids);\n\n\tif (results)\n\t\tpfree(results);\n\n\treturn (numOfFailed == 0);\n}\n\n\nbool\ndispatchDtxCommand(const char *cmd)\n{\n\tint\t\t\ti,\n\t\t\t\tnumOfFailed = 0;\n\n\tCdbPgResults cdb_pgresults = {NULL, 0};\n\n\telog(DTM_DEBUG5, \"dispatchDtxCommand: '%s'\", cmd);\n\n\tif (currentGxactWriterGangLost())\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"writer gang of current global transaction is lost\")));\n\t\treturn false;\n\t}\n\n\tCdbDispatchCommand(cmd, DF_NEED_TWO_PHASE, &cdb_pgresults);\n\n\tif (cdb_pgresults.numResults == 0)\n\t{\n\t\treturn false;\t\t\t\n\t}\n\n\tfor (i = 0; i < cdb_pgresults.numResults; i++)\n\t{\n\t\tchar\t   *cmdStatus;\n\t\tExecStatusType resultStatus;\n\n\t\t\n\t\tresultStatus = PQresultStatus(cdb_pgresults.pg_results[i]);\n\t\tif (resultStatus != PGRES_COMMAND_OK &&\n\t\t\tresultStatus != PGRES_TUPLES_OK)\n\t\t{\n\t\t\tnumOfFailed++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tcmdStatus = PQcmdStatus(cdb_pgresults.pg_results[i]);\n\n\t\t\telog(DEBUG3, \"DTM: status message cmd '%s' [%d] result '%s'\", cmd, i, cmdStatus);\n\t\t\tif (strncmp(cmdStatus, cmd, strlen(cmdStatus)) != 0)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tnumOfFailed++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcdbdisp_clearCdbPgResults(&cdb_pgresults);\n\n\treturn (numOfFailed == 0);\n}\n\n\nvoid\nresetTmGxact(void)\n{\n\tAssert(MyTmGxact->gxid == InvalidDistributedTransactionId);\n\tMyTmGxact->xminDistributedSnapshot = InvalidDistributedTransactionId;\n\tMyTmGxact->includeInCkpt = false;\n\tMyTmGxact->sessionId = 0;\n\n\tMyTmGxactLocal->explicitBeginRemembered = false;\n\tMyTmGxactLocal->writerGangLost = false;\n\tMyTmGxactLocal->dtxSegmentsMap = NULL;\n\tMyTmGxactLocal->dtxSegments = NIL;\n\tMyTmGxactLocal->isOnePhaseCommit = false;\n\tif (MyTmGxactLocal->waitGxids != NULL)\n\t{\n\t\tlist_free(MyTmGxactLocal->waitGxids);\n\t\tMyTmGxactLocal->waitGxids = NULL;\n\t}\n\tsetCurrentDtxState(DTX_STATE_NONE);\n}\n\nbool\ngetNextDistributedXactStatus(TMGALLXACTSTATUS *allDistributedXactStatus, TMGXACTSTATUS **distributedXactStatus)\n{\n\tif (allDistributedXactStatus->next >= allDistributedXactStatus->count)\n\t{\n\t\treturn false;\n\t}\n\n\t*distributedXactStatus = &allDistributedXactStatus->statusArray[allDistributedXactStatus->next];\n\tallDistributedXactStatus->next++;\n\n\treturn true;\n}\n\n\nvoid\ninsertingDistributedCommitted(void)\n{\n\telog(DTM_DEBUG5,\n\t\t \"insertingDistributedCommitted entering in state = %s\",\n\t\t DtxStateToString(MyTmGxactLocal->state));\n\n\tAssert(MyTmGxactLocal->state == DTX_STATE_PREPARED);\n\tsetCurrentDtxState(DTX_STATE_INSERTING_COMMITTED);\n}\n\n\nvoid\ninsertedDistributedCommitted(void)\n{\n\tSIMPLE_FAULT_INJECTOR(\"start_insertedDistributedCommitted\");\n\tereport(DTM_DEBUG5,\n\t\t\t(errmsg(\"entering insertedDistributedCommitted\"),\n\t\t\tTM_ERRDETAIL));\n\n\tAssert(MyTmGxactLocal->state == DTX_STATE_INSERTING_COMMITTED);\n\tsetCurrentDtxState(DTX_STATE_INSERTED_COMMITTED);\n\n\t\n\tAssert(MyPgXact->delayChkpt);\n\tif (IS_QUERY_DISPATCHER())\n\t\tMyTmGxact->includeInCkpt = true;\n}\n\n\nvoid\nverify_shared_snapshot_ready(int cid)\n{\n\tAssert (Gp_role == GP_ROLE_DISPATCH);\n\n\t\n\tif (MySessionState->latestCursorCommandId == cid)\n\t\treturn;\n\n\tCdbDispatchCommand(\"set gp_write_shared_snapshot=true\",\n\t\t\t\t\t   DF_CANCEL_ON_ERROR |\n\t\t\t\t\t   DF_WITH_SNAPSHOT |\n\t\t\t\t\t   DF_NEED_TWO_PHASE,\n\t\t\t\t\t   NULL);\n\n\tdumpSharedLocalSnapshot_forCursor();\n\tMySessionState->latestCursorCommandId = cid;\n}\n\n\nvoid\nassign_gp_write_shared_snapshot(bool newval, void *extra)\n{\n\n\n\telog(DEBUG1, \"SET gp_write_shared_snapshot: %s\",\n\t\t (newval ? \"true\" : \"false\"));\n\n\n\t\n\tif (newval)\n\t{\n\t\tif (Gp_role == GP_ROLE_EXECUTE)\n\t\t{\n\t\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\n\t\t\tif (Gp_is_writer)\n\t\t\t{\n\t\t\t\tdumpSharedLocalSnapshot_forCursor();\n\t\t\t}\n\n\t\t\tPopActiveSnapshot();\n\t\t}\n\t}\n}\n\nstatic void\ndoQEDistributedExplicitBegin()\n{\n\t\n\tStartTransactionCommand();\n\n\t\n\tBeginTransactionBlock();\n\n\t\n\tCommitTransactionCommand();\n}\n\nstatic bool\nisDtxQueryDispatcher(void)\n{\n\tbool\t\tisDtmStarted;\n\tbool\t\tisSharedLocalSnapshotSlotPresent;\n\n\tisDtmStarted = (shmDtmStarted != NULL && *shmDtmStarted);\n\tisSharedLocalSnapshotSlotPresent = (SharedLocalSnapshotSlot != NULL);\n\n\treturn (Gp_role == GP_ROLE_DISPATCH &&\n\t\t\t(isDtmStarted || EnableHotStandby) &&\n\t\t\tisSharedLocalSnapshotSlotPresent);\n}\n\n\nvoid\nsetupRegularDtxContext(void)\n{\n\tswitch (DistributedTransactionContext)\n\t{\n\t\tcase DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE:\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER:\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (DistributedTransactionContext != DTX_CONTEXT_LOCAL_ONLY)\n\t\t\t{\n\t\t\t\t\n\n\t\t\t\telog(ERROR, \"setupRegularDtxContext finds unexpected DistributedTransactionContext = '%s'\",\n\t\t\t\t\t DtxContextToString(DistributedTransactionContext));\n\t\t\t}\n\n\t\t\t\n\n\t\t\tAssert(QEDtxContextInfo.distributedXid == InvalidDistributedTransactionId);\n\n\t\t\t\n\t\t\tAssert(DistributedTransactionContext == DTX_CONTEXT_LOCAL_ONLY);\n\n\t\t\tif (isDtxQueryDispatcher())\n\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE);\n\n\t\t\tbreak;\n\t}\n\n\telog(DTM_DEBUG5, \"setupRegularDtxContext leaving with DistributedTransactionContext = '%s'.\",\n\t\t DtxContextToString(DistributedTransactionContext));\n}\n\n\nvoid\nsetupQEDtxContext(DtxContextInfo *dtxContextInfo)\n{\n\tDistributedSnapshot *distributedSnapshot;\n\tint\t\t\ttxnOptions;\n\tbool\t\tneedDtx;\n\tbool\t\texplicitBegin;\n\tbool\t\thaveDistributedSnapshot;\n\tbool\t\tisEntryDbSingleton = false;\n\tbool\t\tisReaderQE = false;\n\tbool\t\tisWriterQE = false;\n\tbool\t\tisSharedLocalSnapshotSlotPresent;\n\n\tAssert(dtxContextInfo != NULL);\n\n\t\n\tdistributedSnapshot = &dtxContextInfo->distributedSnapshot;\n\ttxnOptions = dtxContextInfo->distributedTxnOptions;\n\n\tneedDtx = isMppTxOptions_NeedDtx(txnOptions);\n\texplicitBegin = isMppTxOptions_ExplicitBegin(txnOptions);\n\n\thaveDistributedSnapshot = dtxContextInfo->haveDistributedSnapshot;\n\tisSharedLocalSnapshotSlotPresent = (SharedLocalSnapshotSlot != NULL);\n\n\tif (DEBUG5 >= log_min_messages || Debug_print_full_dtm)\n\t{\n\t\telog(DTM_DEBUG5,\n\t\t\t \"setupQEDtxContext inputs (part 1): Gp_role = %s, Gp_is_writer = %s, \"\n\t\t\t \"txnOptions = 0x%x, needDtx = %s, explicitBegin = %s, isoLevel = %s, readOnly = %s, haveDistributedSnapshot = %s.\",\n\t\t\t role_to_string(Gp_role), (Gp_is_writer ? \"true\" : \"false\"), txnOptions,\n\t\t\t (needDtx ? \"true\" : \"false\"), (explicitBegin ? \"true\" : \"false\"),\n\t\t\t IsoLevelAsUpperString(mppTxOptions_IsoLevel(txnOptions)), (isMppTxOptions_ReadOnly(txnOptions) ? \"true\" : \"false\"),\n\t\t\t (haveDistributedSnapshot ? \"true\" : \"false\"));\n\t\telog(DTM_DEBUG5,\n\t\t\t \"setupQEDtxContext inputs (part 2): distributedXid = \"UINT64_FORMAT\", isSharedLocalSnapshotSlotPresent = %s.\",\n\t\t\t dtxContextInfo->distributedXid,\n\t\t\t (isSharedLocalSnapshotSlotPresent ? \"true\" : \"false\"));\n\n\t\tif (haveDistributedSnapshot)\n\t\t{\n\t\t\telog(DTM_DEBUG5,\n\t\t\t\t \"setupQEDtxContext inputs (part 2a): distributedXid = \"UINT64_FORMAT\", \"\n\t\t\t\t \"distributedSnapshotData (xmin = \"UINT64_FORMAT\", xmax = \"UINT64_FORMAT\", xcnt = %u), distributedCommandId = %d\",\n\t\t\t\t dtxContextInfo->distributedXid,\n\t\t\t\t distributedSnapshot->xmin, distributedSnapshot->xmax,\n\t\t\t\t distributedSnapshot->count,\n\t\t\t\t dtxContextInfo->curcid);\n\t\t}\n\t\tif (isSharedLocalSnapshotSlotPresent)\n\t\t{\n\t\t\tif (DTM_DEBUG5 >= log_min_messages)\n\t\t\t{\n\t\t\t\tLWLockAcquire(SharedLocalSnapshotSlot->slotLock, LW_SHARED);\n\t\t\t\telog(DTM_DEBUG5,\n\t\t\t\t\t \"setupQEDtxContext inputs (part 2b):  shared local snapshot xid = \" UINT64_FORMAT \" \"\n\t\t\t\t\t \"(xmin: %u xmax: %u xcnt: %u) curcid: %d, QDxid = \"UINT64_FORMAT\"/%u\",\n\t\t\t\t\t U64FromFullTransactionId(SharedLocalSnapshotSlot->fullXid),\n\t\t\t\t\t SharedLocalSnapshotSlot->snapshot.xmin,\n\t\t\t\t\t SharedLocalSnapshotSlot->snapshot.xmax,\n\t\t\t\t\t SharedLocalSnapshotSlot->snapshot.xcnt,\n\t\t\t\t\t SharedLocalSnapshotSlot->snapshot.curcid,\n\t\t\t\t\t SharedLocalSnapshotSlot->distributedXid,\n\t\t\t\t\t SharedLocalSnapshotSlot->segmateSync);\n\t\t\t\tLWLockRelease(SharedLocalSnapshotSlot->slotLock);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (Gp_role)\n\t{\n\t\tcase GP_ROLE_EXECUTE:\n\t\t\tif (IS_QUERY_DISPATCHER() && !Gp_is_writer)\n\t\t\t{\n\t\t\t\tisEntryDbSingleton = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (SharedLocalSnapshotSlot == NULL)\n\t\t\t\t{\n\t\t\t\t\tif (explicitBegin || haveDistributedSnapshot)\n\t\t\t\t\t{\n\t\t\t\t\t\telog(ERROR, \"setupQEDtxContext not expecting distributed begin or snapshot when no Snapshot slot exists\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (Gp_is_writer)\n\t\t\t\t\t{\n\t\t\t\t\t\tisWriterQE = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tisReaderQE = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tAssert(DistributedTransactionContext == DTX_CONTEXT_LOCAL_ONLY);\n\t\t\telog(DTM_DEBUG5,\n\t\t\t\t \"setupQEDtxContext leaving context = 'Local Only' for Gp_role = %s\", role_to_string(Gp_role));\n\t\t\treturn;\n\t}\n\n\telog(DTM_DEBUG5,\n\t\t \"setupQEDtxContext intermediate result: isEntryDbSingleton = %s, isWriterQE = %s, isReaderQE = %s.\",\n\t\t (isEntryDbSingleton ? \"true\" : \"false\"),\n\t\t (isWriterQE ? \"true\" : \"false\"), (isReaderQE ? \"true\" : \"false\"));\n\n\t\n\tDtxContextInfo_Copy(&QEDtxContextInfo, dtxContextInfo);\n\n\tswitch (DistributedTransactionContext)\n\t{\n\t\tcase DTX_CONTEXT_LOCAL_ONLY:\n\t\t\tif (isEntryDbSingleton && haveDistributedSnapshot)\n\t\t\t{\n\t\t\t\t\n\n\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_ENTRY_DB_SINGLETON);\n\t\t\t}\n\t\t\telse if (isReaderQE && haveDistributedSnapshot)\n\t\t\t{\n\t\t\t\t\n\n\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_READER);\n\t\t\t}\n\t\t\telse if (isWriterQE && (explicitBegin || needDtx))\n\t\t\t{\n\t\t\t\tif (!haveDistributedSnapshot)\n\t\t\t\t{\n\t\t\t\t\telog(DTM_DEBUG5,\n\t\t\t\t\t\t \"setupQEDtxContext Segment Writer is involved in a distributed transaction without a distributed snapshot...\");\n\t\t\t\t}\n\n\t\t\t\tif (IsTransactionOrTransactionBlock())\n\t\t\t\t{\n\t\t\t\t\telog(ERROR, \"Starting an explicit distributed transaction in segment -- cannot already be in a transaction\");\n\t\t\t\t}\n\n\t\t\t\tif (explicitBegin)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER);\n\n\t\t\t\t\tdoQEDistributedExplicitBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER);\n\t\t\t}\n\t\t\telse if (haveDistributedSnapshot)\n\t\t\t{\n\t\t\t\tif (IsTransactionOrTransactionBlock())\n\t\t\t\t{\n\t\t\t\t\telog(ERROR,\n\t\t\t\t\t\t \"Going to start a local implicit transaction in segment using a distribute \"\n\t\t\t\t\t\t \"snapshot -- cannot already be in a transaction\");\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_AUTO_COMMIT_IMPLICIT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(!haveDistributedSnapshot);\n\n\t\t\t\t\n\t\t\t\tAssert(DistributedTransactionContext == DTX_CONTEXT_LOCAL_ONLY);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER:\n\n\t\t\tAssert(IsTransactionOrTransactionBlock());\n\n\t\t\tif (explicitBegin)\n\t\t\t{\n\t\t\t\telog(ERROR, \"Cannot have an explicit BEGIN statement...\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_AUTO_COMMIT_IMPLICIT:\n\t\t\telog(ERROR, \"We should have left this transition state '%s' at the end of the previous command\",\n\t\t\t\t DtxContextToString(DistributedTransactionContext));\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER:\n\t\t\tAssert(IsTransactionOrTransactionBlock());\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_ENTRY_DB_SINGLETON:\n\t\tcase DTX_CONTEXT_QE_READER:\n\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase DTX_CONTEXT_QE_PREPARED:\n\t\tcase DTX_CONTEXT_QE_FINISH_PREPARED:\n\t\t\telog(ERROR, \"We should not be trying to execute a query in state '%s'\",\n\t\t\t\t DtxContextToString(DistributedTransactionContext));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(PANIC, \"Unexpected segment distribute transaction context value: %d\",\n\t\t\t\t (int) DistributedTransactionContext);\n\t\t\tbreak;\n\t}\n\n\telog(DTM_DEBUG5, \"setupQEDtxContext final result: DistributedTransactionContext = '%s'.\",\n\t\t DtxContextToString(DistributedTransactionContext));\n\n\tif (haveDistributedSnapshot)\n\t{\n\t\telog((Debug_print_snapshot_dtm ? LOG : DEBUG5), \"[Distributed Snapshot \n\t\t\t dtxContextInfo->distributedSnapshot.distribSnapshotId,\n\t\t\t dtxContextInfo->curcid,\n\t\t\t getDistributedTransactionId(),\n\t\t\t DtxContextToString(DistributedTransactionContext));\n\t}\n\n}\n\nvoid\nfinishDistributedTransactionContext(char *debugCaller, bool aborted)\n{\n\tDistributedTransactionId gxid;\n\n\t\n\tif (isCurrentDtxActivated() &&\n\t\t(MyTmGxactLocal->state != DTX_STATE_RETRY_COMMIT_PREPARED &&\n\t\t MyTmGxactLocal->state != DTX_STATE_RETRY_ABORT_PREPARED))\n\t{\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"Unexpected dtx status (caller = %s).\", debugCaller),\n\t\t\t\tTM_ERRDETAIL));\n\t}\n\n\tgxid = getDistributedTransactionId();\n\telog(DTM_DEBUG5,\n\t\t \"finishDistributedTransactionContext called to change DistributedTransactionContext from %s to %s (caller = %s, gxid = \"UINT64_FORMAT\")\",\n\t\t DtxContextToString(DistributedTransactionContext),\n\t\t DtxContextToString(DTX_CONTEXT_LOCAL_ONLY),\n\t\t debugCaller,\n\t\t gxid);\n\n\tsetDistributedTransactionContext(DTX_CONTEXT_LOCAL_ONLY);\n\n\tDtxContextInfo_Reset(&QEDtxContextInfo);\n\n}\n\nstatic void\nrememberDtxExplicitBegin(void)\n{\n\tAssert (isCurrentDtxActivated());\n\n\tif (!MyTmGxactLocal->explicitBeginRemembered)\n\t{\n\t\tereport(DTM_DEBUG5,\n\t\t\t\t(errmsg(\"rememberDtxExplicitBegin explicit BEGIN\"),\n\t\t\t\tTM_ERRDETAIL));\n\t\tMyTmGxactLocal->explicitBeginRemembered = true;\n\t}\n\telse\n\t{\n\t\tereport(DTM_DEBUG5,\n\t\t\t\t(errmsg(\"rememberDtxExplicitBegin already an explicit BEGIN\"),\n\t\t\t\tTM_ERRDETAIL));\n\t}\n}\n\nbool\nisDtxExplicitBegin(void)\n{\n\treturn (isCurrentDtxActivated() && MyTmGxactLocal->explicitBeginRemembered);\n}\n\n\nvoid\nsendDtxExplicitBegin(void)\n{\n\tif (Gp_role != GP_ROLE_DISPATCH)\n\t\treturn;\n\n\tsetupDtxTransaction();\n\trememberDtxExplicitBegin();\n}\n\n\nstatic void\nperformDtxProtocolPrepare(const char *gid)\n{\n\tSIMPLE_FAULT_INJECTOR(\"qe_start_prepared\");\n\n\tStartTransactionCommand();\n\n\telog(DTM_DEBUG5, \"performDtxProtocolCommand going to call PrepareTransactionBlock for distributed transaction (id = '%s')\", gid);\n\tif (!PrepareTransactionBlock((char *) gid))\n\t{\n\t\telog(ERROR, \"Prepare of distributed transaction %s failed\", gid);\n\t\treturn;\n\t}\n\n\t\n\tCommitTransactionCommand();\n\n\telog(DTM_DEBUG5, \"Prepare of distributed transaction succeeded (id = '%s')\", gid);\n\n\tsetDistributedTransactionContext(DTX_CONTEXT_QE_PREPARED);\n}\n\nstatic void\nsendWaitGxidsToQD(List *waitGxids)\n{\n\tListCell *lc;\n\tStringInfoData buf;\n\tint len = list_length(waitGxids);\n\n\tif (len == 0)\n\t\treturn;\n\n\tpq_beginmessage(&buf, 'w');\n\tpq_sendint(&buf, len, 4);\n\tforeach(lc, waitGxids)\n\t{\n\t\tpq_sendint(&buf, lfirst_int(lc), 4);\n\t}\n\tpq_endmessage(&buf);\n}\n\nstatic void\nperformDtxProtocolCommitOnePhase(const char *gid)\n{\n\tDistributedTransactionId gxid;\n\tList *waitGxids = list_copy(MyTmGxactLocal->waitGxids);\n\n\tSIMPLE_FAULT_INJECTOR(\"start_performDtxProtocolCommitOnePhase\");\n\n\telog(DTM_DEBUG5,\n\t\t \"performDtxProtocolCommitOnePhase going to call CommitTransaction for distributed transaction %s\", gid);\n\n\tdtxDeformGid(gid, &gxid);\n\tAssert(gxid == getDistributedTransactionId());\n\tMyTmGxactLocal->isOnePhaseCommit = true;\n\n\tStartTransactionCommand();\n\n\tif (!EndTransactionBlock(false))\n\t{\n\t\telog(ERROR, \"One-phase Commit of distributed transaction %s failed\", gid);\n\t\treturn;\n\t}\n\n\t\n\tCommitTransactionCommand();\n\n\tfinishDistributedTransactionContext(\"performDtxProtocolCommitOnePhase -- Commit onephase\", false);\n\tMyProc->localDistribXactData.state = LOCALDISTRIBXACT_STATE_NONE;\n\n\tsendWaitGxidsToQD(waitGxids);\n}\n\n\nstatic void\nperformDtxProtocolCommitPrepared(const char *gid, bool raiseErrorIfNotFound)\n{\n\tSIMPLE_FAULT_INJECTOR(\"qe_start_commit_prepared\");\n\tAssert(Gp_role == GP_ROLE_EXECUTE);\n\n\telog(DTM_DEBUG5,\n\t\t \"performDtxProtocolCommitPrepared going to call FinishPreparedTransaction for distributed transaction %s\", gid);\n\n\tList *waitGxids = list_copy(MyTmGxactLocal->waitGxids);\n\n\tStartTransactionCommand();\n\n\t\n\tPG_TRY();\n\t{\n\t\tFinishPreparedTransaction((char *) gid,  true, raiseErrorIfNotFound);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfinishDistributedTransactionContext(\"performDtxProtocolCommitPrepared -- Commit Prepared (error case)\", false);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t\n\tCommitTransactionCommand();\n\n\tsendWaitGxidsToQD(waitGxids);\n\n\tfinishDistributedTransactionContext(\"performDtxProtocolCommitPrepared -- Commit Prepared\", false);\n\tSIMPLE_FAULT_INJECTOR(\"finish_commit_prepared\");\n}\n\n\nstatic void\nperformDtxProtocolAbortPrepared(const char *gid, bool raiseErrorIfNotFound)\n{\n\tAssert(Gp_role == GP_ROLE_EXECUTE);\n\n\telog(DTM_DEBUG5, \"performDtxProtocolAbortPrepared going to call FinishPreparedTransaction for distributed transaction %s\", gid);\n\n\tStartTransactionCommand();\n\n\t\n\tPG_TRY();\n\t{\n\t\tFinishPreparedTransaction((char *) gid,  false, raiseErrorIfNotFound);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfinishDistributedTransactionContext(\"performDtxProtocolAbortPrepared -- Abort Prepared (error case)\", true);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t\n\tCommitTransactionCommand();\n\n\tfinishDistributedTransactionContext(\"performDtxProtocolAbortPrepared -- Abort Prepared\", true);\n}\n\n\nvoid\nperformDtxProtocolCommand(DtxProtocolCommand dtxProtocolCommand,\n\t\t\t\t\t\t  const char *gid,\n\t\t\t\t\t\t  DtxContextInfo *contextInfo)\n{\n\telog(DTM_DEBUG5,\n\t\t \"performDtxProtocolCommand called with DTX protocol = %s, segment distribute transaction context: '%s'\",\n\t\t DtxProtocolCommandToString(dtxProtocolCommand), DtxContextToString(DistributedTransactionContext));\n\n\tswitch (dtxProtocolCommand)\n\t{\n\t\tcase DTX_PROTOCOL_COMMAND_ABORT_NO_PREPARED:\n\t\t\telog(DTM_DEBUG5,\n\t\t\t\t \"performDtxProtocolCommand going to call AbortOutOfAnyTransaction for distributed transaction %s\", gid);\n\t\t\tAbortOutOfAnyTransaction();\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_PREPARE:\n\t\tcase DTX_PROTOCOL_COMMAND_COMMIT_ONEPHASE:\n\n\t\t\t\n\t\t\tswitch (DistributedTransactionContext)\n\t\t\t{\n\t\t\t\tcase DTX_CONTEXT_LOCAL_ONLY:\n\n\t\t\t\t\t\n\t\t\t\t\telog(ERROR, \"Distributed transaction %s not found\", gid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER:\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER:\n\t\t\t\t\tif (dtxProtocolCommand == DTX_PROTOCOL_COMMAND_COMMIT_ONEPHASE)\n\t\t\t\t\t\tperformDtxProtocolCommitOnePhase(gid);\n\t\t\t\t\telse\n\t\t\t\t\t\tperformDtxProtocolPrepare(gid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE:\n\t\t\t\tcase DTX_CONTEXT_QD_RETRY_PHASE_2:\n\t\t\t\tcase DTX_CONTEXT_QE_PREPARED:\n\t\t\t\tcase DTX_CONTEXT_QE_FINISH_PREPARED:\n\t\t\t\tcase DTX_CONTEXT_QE_ENTRY_DB_SINGLETON:\n\t\t\t\tcase DTX_CONTEXT_QE_READER:\n\t\t\t\t\telog(FATAL, \"Unexpected segment distribute transaction context: '%s'\",\n\t\t\t\t\t\t DtxContextToString(DistributedTransactionContext));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(PANIC, \"Unexpected segment distribute transaction context value: %d\",\n\t\t\t\t\t\t (int) DistributedTransactionContext);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_ABORT_SOME_PREPARED:\n\t\t\tswitch (DistributedTransactionContext)\n\t\t\t{\n\t\t\t\tcase DTX_CONTEXT_LOCAL_ONLY:\n\n\t\t\t\t\t\n\t\t\t\t\telog(DTM_DEBUG3, \"Distributed transaction %s not found during abort\", gid);\n\t\t\t\t\tAbortOutOfAnyTransaction();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER:\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER:\n\t\t\t\t\tAbortOutOfAnyTransaction();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTX_CONTEXT_QE_PREPARED:\n\t\t\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_FINISH_PREPARED);\n\t\t\t\t\tperformDtxProtocolAbortPrepared(gid,  true);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE:\n\t\t\t\tcase DTX_CONTEXT_QD_RETRY_PHASE_2:\n\t\t\t\tcase DTX_CONTEXT_QE_ENTRY_DB_SINGLETON:\n\t\t\t\tcase DTX_CONTEXT_QE_READER:\n\t\t\t\t\telog(PANIC, \"Unexpected segment distribute transaction context: '%s'\",\n\t\t\t\t\t\t DtxContextToString(DistributedTransactionContext));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(PANIC, \"Unexpected segment distribute transaction context value: %d\",\n\t\t\t\t\t\t (int) DistributedTransactionContext);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_COMMIT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_QE_PREPARED);\n\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_FINISH_PREPARED);\n\t\t\tperformDtxProtocolCommitPrepared(gid,  true);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_ABORT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_QE_PREPARED);\n\t\t\tsetDistributedTransactionContext(DTX_CONTEXT_QE_FINISH_PREPARED);\n\t\t\tperformDtxProtocolAbortPrepared(gid,  true);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_RETRY_COMMIT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_LOCAL_ONLY);\n\t\t\tperformDtxProtocolCommitPrepared(gid,  false);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_RETRY_ABORT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_LOCAL_ONLY);\n\t\t\tperformDtxProtocolAbortPrepared(gid,  false);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_RECOVERY_COMMIT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_LOCAL_ONLY);\n\t\t\tperformDtxProtocolCommitPrepared(gid,  false);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_RECOVERY_ABORT_PREPARED:\n\t\t\trequireDistributedTransactionContext(DTX_CONTEXT_LOCAL_ONLY);\n\t\t\tperformDtxProtocolAbortPrepared(gid,  false);\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_SUBTRANSACTION_BEGIN_INTERNAL:\n\t\t\tswitch (DistributedTransactionContext)\n\t\t\t{\n\t\t\t\tcase DTX_CONTEXT_LOCAL_ONLY:\n\n\t\t\t\t\t\n\t\t\t\t\tsetupQEDtxContext(contextInfo);\n\t\t\t\t\tStartTransactionCommand();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER:\n\n\t\t\t\t\t\n\t\t\t\tcase DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER:\n\t\t\t\tcase DTX_CONTEXT_QE_READER:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\n\t\t\t\t\tAssert(false);\n\t\t\t\t\telog(DTM_DEBUG5,\n\t\t\t\t\t\t \" SUBTRANSACTION_BEGIN_INTERNAL distributed transaction context invalid: %d\",\n\t\t\t\t\t\t (int) DistributedTransactionContext);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBeginInternalSubTransaction(NULL);\n\t\t\tAssert(contextInfo->nestingLevel + 1 == GetCurrentTransactionNestLevel());\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_SUBTRANSACTION_RELEASE_INTERNAL:\n\t\t\tAssert(contextInfo->nestingLevel == GetCurrentTransactionNestLevel());\n\t\t\tReleaseCurrentSubTransaction();\n\t\t\tbreak;\n\n\t\tcase DTX_PROTOCOL_COMMAND_SUBTRANSACTION_ROLLBACK_INTERNAL:\n\n\t\t\t\n\t\t\tif ((contextInfo->nestingLevel + 1) > GetCurrentTransactionNestLevel())\n\t\t\t{\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"transaction %s at level %d already processed (current level %d)\",\n\t\t\t\t\t\t\t\tgid, contextInfo->nestingLevel, GetCurrentTransactionNestLevel())));\n\t\t\t}\n\n\t\t\tunsigned int i = GetCurrentTransactionNestLevel() - contextInfo->nestingLevel;\n\n\t\t\twhile (i > 0)\n\t\t\t{\n\t\t\t\tRollbackAndReleaseCurrentSubTransaction();\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t\tAssert(contextInfo->nestingLevel == GetCurrentTransactionNestLevel());\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"Unrecognized dtx protocol command: %d\",\n\t\t\t\t (int) dtxProtocolCommand);\n\t\t\tbreak;\n\t}\n\telog(DTM_DEBUG5, \"performDtxProtocolCommand successful return for distributed transaction %s\", gid);\n}\n\nvoid\nmarkCurrentGxactWriterGangLost(void)\n{\n\tMyTmGxactLocal->writerGangLost = true;\n}\n\nbool\ncurrentGxactWriterGangLost(void)\n{\n\treturn MyTmGxactLocal->writerGangLost;\n}\n\n\nvoid\naddToGxactDtxSegments(Gang *gang)\n{\n\tSegmentDatabaseDescriptor *segdbDesc;\n\tMemoryContext oldContext;\n\tint segindex;\n\tint i;\n\n\tif (!isCurrentDtxActivated())\n\t\treturn;\n\n\t\n\tif (list_length(MyTmGxactLocal->dtxSegments) >= getgpsegmentCount())\n\t\treturn;\n\n\toldContext = MemoryContextSwitchTo(TopTransactionContext);\n\tfor (i = 0; i < gang->size; i++)\n\t{\n\t\tsegdbDesc = gang->db_descriptors[i];\n\t\tAssert(segdbDesc);\n\t\tsegindex = segdbDesc->segindex;\n\n\t\t\n\t\tif (segindex == -1)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (bms_is_member(segindex, MyTmGxactLocal->dtxSegmentsMap))\n\t\t\tcontinue;\n\n\t\tMyTmGxactLocal->dtxSegmentsMap =\n\t\t\tbms_add_member(MyTmGxactLocal->dtxSegmentsMap, segindex);\n\n\t\tMyTmGxactLocal->dtxSegments =\n\t\t\tlappend_int(MyTmGxactLocal->dtxSegments, segindex);\n\t}\n\tMemoryContextSwitchTo(oldContext);\n}\n\nbool\nCurrentDtxIsRollingback(void)\n{\n\treturn (MyTmGxactLocal->state == DTX_STATE_NOTIFYING_ABORT_NO_PREPARED ||\n\t\t\tMyTmGxactLocal->state == DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED ||\n\t\t\tMyTmGxactLocal->state == DTX_STATE_NOTIFYING_ABORT_PREPARED ||\n\t\t\tMyTmGxactLocal->state == DTX_STATE_RETRY_ABORT_PREPARED);\n}\n\nDatum\ngp_get_next_gxid(PG_FUNCTION_ARGS)\n{\n\tDistributedTransactionId next_gxid;\n\n\tif (!superuser())\n\t\tereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t(errmsg(\"Superuser only to execute it\"))));\n\n\tSpinLockAcquire(shmGxidGenLock);\n\tnext_gxid = ShmemVariableCache->nextGxid;\n\tSpinLockRelease(shmGxidGenLock);\n\n\tPG_RETURN_UINT64(next_gxid);\n}\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse ereport log",
        "file_path": "src/backend/cdb/cdbtm.c:1097"
    },
    {
        "log": "elog(ERROR,\n\n\t\t\telog(LOG,\n\n\t\t\t\t\"invalid in-recovery message %s \"\n\t\t\t\t\"(content=%d, dbid=%d) state=%d\",\n\t\t\t\tPQerrorMessage(ftsInfo->conn),\n\t\t\t\tftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\tftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\tftsInfo->state);\n\t\t\treturn;\n\t\t}\n\t\ttmpptr = ((uint64) tmp_xlogid) << 32 | (uint64) tmp_xrecoff;\n\n\t\t\n\t\tif (tmpptr <= ftsInfo->xlogrecptr)\n\t\t{\n\t\t\tftsInfo->restart_state = PM_IN_RECOVERY_NOT_MAKING_PROGRESS;\n\t\t\telog(LOG, \"FTS: detected segment is in recovery mode and not making progress (content=%d) \"\n\t\t\t\t \"primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t ftsInfo->mirror_cdbinfo->config->dbid);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tftsInfo->restart_state = PM_IN_RECOVERY_MAKING_PROGRESS;\n\t\t\tftsInfo->xlogrecptr = tmpptr;\n\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t   \"FTS: detected segment is in recovery mode replayed (%X/%X) (content=%d) \"\n\t\t\t\t   \"primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t   (uint32) (tmpptr >> 32),\n\t\t\t\t   (uint32) tmpptr,\n\t\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t   ftsInfo->mirror_cdbinfo->config->dbid);\n\t\t}\n\t}\n\telse if (strstr(PQerrorMessage(ftsInfo->conn), _(POSTMASTER_IN_RESET_MSG)))\n\t{\n\t\tftsInfo->restart_state = PM_IN_RESETTING;\n\t\telog(LOG, \"FTS: detected segment is in RESET state (content=%d) \"\n\t\t\t\t   \"primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t   ftsInfo->mirror_cdbinfo->config->dbid);\n\t}\n}\n\n\nstatic void\nftsConnect(fts_context *context)\n{\n\tint i;\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tfts_segment_info *ftsInfo = &context->perSegInfos[i];\n\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t   \"FTS: ftsConnect (content=%d, dbid=%d) state=%d, \"\n\t\t\t   \"retry_count=%d, conn->status=%d\",\n\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t   ftsInfo->state, ftsInfo->retry_count,\n\t\t\t   ftsInfo->conn ? ftsInfo->conn->status : -1);\n\t\tif (ftsInfo->conn && PQstatus(ftsInfo->conn) == CONNECTION_OK)\n\t\t\tcontinue;\n\t\tswitch(ftsInfo->state)\n\t\t{\n\t\t\tcase FTS_PROBE_SEGMENT:\n\t\t\tcase FTS_SYNCREP_OFF_SEGMENT:\n\t\t\tcase FTS_PROMOTE_SEGMENT:\n\t\t\t\t\n\t\t\t\tftsInfo->restart_state = PM_NOT_IN_RESTART;\n\t\t\t\tif (ftsInfo->conn == NULL)\n\t\t\t\t{\n\t\t\t\t\tAssertImply(ftsInfo->retry_count > 0,\n\t\t\t\t\t\t\t\tftsInfo->retry_count <= gp_fts_probe_retries);\n\t\t\t\t\tif (!ftsConnectStart(ftsInfo))\n\t\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t}\n\t\t\t\telse if (ftsInfo->poll_revents & (POLLOUT | POLLIN))\n\t\t\t\t{\n\t\t\t\t\tswitch(PQconnectPoll(ftsInfo->conn))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase PGRES_POLLING_OK:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t\t\t\t\t\t   \"FTS: established libpq connection \"\n\t\t\t\t\t\t\t\t   \"(content=%d, dbid=%d) state=%d, \"\n\t\t\t\t\t\t\t\t   \"retry_count=%d, conn->status=%d\",\n\t\t\t\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t\t\t   ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t\t\t   ftsInfo->conn->status);\n\t\t\t\t\t\t\tftsInfo->poll_events = POLLOUT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PGRES_POLLING_READING:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tftsInfo->poll_events |= POLLIN;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PGRES_POLLING_WRITING:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tftsInfo->poll_events |= POLLOUT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PGRES_POLLING_FAILED:\n\t\t\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t\t\t\tcheckIfFailedDueToNormalRestart(ftsInfo);\n\t\t\t\t\t\t\telog(LOG, \"FTS: cannot establish libpq connection \"\n\t\t\t\t\t\t\t\t \"(content=%d, dbid=%d): %s, retry_count=%d\",\n\t\t\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t\t\t PQerrorMessage(ftsInfo->conn),\n\t\t\t\t\t\t\t\t ftsInfo->retry_count);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\telog(ERROR, \"FTS: invalid response to PQconnectPoll\"\n\t\t\t\t\t\t\t\t \" (content=%d, dbid=%d): %s\",\n\t\t\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t\t\t PQerrorMessage(ftsInfo->conn));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t   \"FTS: ftsConnect (content=%d, dbid=%d) state=%d, \"\n\t\t\t\t\t\t   \"retry_count=%d, conn->status=%d pollfd.revents unset\",\n\t\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t   ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t   ftsInfo->conn ? ftsInfo->conn->status : -1);\n\t\t\t\tbreak;\n\t\t\tcase FTS_PROBE_SUCCESS:\n\t\t\tcase FTS_SYNCREP_OFF_SUCCESS:\n\t\t\tcase FTS_PROMOTE_SUCCESS:\n\t\t\tcase FTS_PROBE_FAILED:\n\t\t\tcase FTS_SYNCREP_OFF_FAILED:\n\t\t\tcase FTS_PROMOTE_FAILED:\n\t\t\tcase FTS_PROBE_RETRY_WAIT:\n\t\t\tcase FTS_SYNCREP_OFF_RETRY_WAIT:\n\t\t\tcase FTS_PROMOTE_RETRY_WAIT:\n\t\t\tcase FTS_RESPONSE_PROCESSED:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic void\nftsCheckTimeout(fts_segment_info *ftsInfo, pg_time_t now)\n{\n\tif (!IsFtsMessageStateSuccess(ftsInfo->state) &&\n\t\t(int) (now - ftsInfo->startTime) > gp_fts_probe_timeout)\n\t{\n\t\telog(LOG,\n\t\t\t \"FTS timeout detected for (content=%d, dbid=%d) \"\n\t\t\t \"state=%d, retry_count=%d, timeout_count=%d \",\n\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t ftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state,\n\t\t\t ftsInfo->retry_count, ftsInfo->timeout_count);\n\n\t\t\n\t\tftsInfo->timeout_count = 0;\n\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t}\n}\n\nstatic void\nftsPoll(fts_context *context)\n{\n\tint i;\n\tint nfds=0;\n\tint nready;\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tfts_segment_info *ftsInfo = &context->perSegInfos[i];\n\t\tif (ftsInfo->poll_events & (POLLIN|POLLOUT))\n\t\t{\n\t\t\tPollFds[nfds].fd = PQsocket(ftsInfo->conn);\n\t\t\tPollFds[nfds].events = ftsInfo->poll_events;\n\t\t\tPollFds[nfds].revents = 0;\n\t\t\tftsInfo->fd_index = nfds;\n\t\t\tnfds++;\n\t\t}\n\t\telse\n\t\t\tftsInfo->fd_index = -1; \n\t}\n\tif (nfds == 0)\n\t\treturn;\n\n\tnready = poll(PollFds, nfds, 50);\n\tif (nready < 0)\n\t{\n\t\tif (errno == EINTR)\n\t\t{\n\t\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t\t   \"FTS: ftsPoll() interrupted, nfds %d\", nfds);\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"FTS: ftsPoll() failed: nfds %d, %m\", nfds);\n\t}\n\telse if (nready == 0)\n\t{\n\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t   \"FTS: ftsPoll() timed out, nfds %d\", nfds);\n\t}\n\n\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t   \"FTS: ftsPoll() found %d out of %d sockets ready\",\n\t\t   nready, nfds);\n\n\tpg_time_t now = (pg_time_t) time(NULL);\n\n\t\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tfts_segment_info *ftsInfo = &context->perSegInfos[i];\n\n\t\tif (ftsInfo->poll_events & (POLLIN|POLLOUT))\n\t\t{\n\t\t\tAssert(PollFds[ftsInfo->fd_index].fd == PQsocket(ftsInfo->conn));\n\t\t\tftsInfo->poll_revents = PollFds[ftsInfo->fd_index].revents;\n\t\t\t\n\t\t\tif (ftsInfo->poll_revents & ftsInfo->poll_events)\n\t\t\t{\n\t\t\t\tftsInfo->poll_events = 0;\n\t\t\t}\n\t\t\telse if (ftsInfo->poll_revents & (POLLHUP | POLLERR))\n\t\t\t{\n\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\telog(LOG,\n\t\t\t\t\t \"FTS poll failed (revents=%d, events=%d) for \"\n\t\t\t\t\t \"(content=%d, dbid=%d) state=%d, retry_count=%d, \"\n\t\t\t\t\t \"libpq status=%d, asyncStatus=%d\",\n\t\t\t\t\t ftsInfo->poll_revents, ftsInfo->poll_events,\n\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state,\n\t\t\t\t\t ftsInfo->retry_count, ftsInfo->conn->status,\n\t\t\t\t\t ftsInfo->conn->asyncStatus);\n\t\t\t}\n\t\t\telse if (ftsInfo->poll_revents)\n\t\t\t{\n\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\telog(LOG,\n\t\t\t\t\t \"FTS unexpected events (revents=%d, events=%d) for \"\n\t\t\t\t\t \"(content=%d, dbid=%d) state=%d, retry_count=%d, \"\n\t\t\t\t\t \"libpq status=%d, asyncStatus=%d\",\n\t\t\t\t\t ftsInfo->poll_revents, ftsInfo->poll_events,\n\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state,\n\t\t\t\t\t ftsInfo->retry_count, ftsInfo->conn->status,\n\t\t\t\t\t ftsInfo->conn->asyncStatus);\n\t\t\t}\n\t\t\t\n\t\t\tif (!IsFtsMessageStateSuccess(ftsInfo->state) &&\n\t\t\t\tnready == 0)\n\t\t\t{\n\t\t\t\tftsInfo->timeout_count++;\n\t\t\t}\n\t\t\t\n\t\t\tftsCheckTimeout(ftsInfo, now);\n\t\t}\n\t}\n}\n\n\nstatic void\nftsSend(fts_context *context)\n{\n\tfts_segment_info *ftsInfo;\n\tconst char *message_type;\n\tchar message[FTS_MSG_MAX_LEN];\n\tint i;\n\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tftsInfo = &context->perSegInfos[i];\n\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t   \"FTS: ftsSend (content=%d, dbid=%d) state=%d, \"\n\t\t\t   \"retry_count=%d, conn->asyncStatus=%d\",\n\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t   ftsInfo->state, ftsInfo->retry_count,\n\t\t\t   ftsInfo->conn ? ftsInfo->conn->asyncStatus : -1);\n\t\tswitch(ftsInfo->state)\n\t\t{\n\t\t\tcase FTS_PROBE_SEGMENT:\n\t\t\tcase FTS_SYNCREP_OFF_SEGMENT:\n\t\t\tcase FTS_PROMOTE_SEGMENT:\n\t\t\t\t\n\t\t\t\tif (PQstatus(ftsInfo->conn) != CONNECTION_OK ||\n\t\t\t\t\tftsInfo->conn->asyncStatus != PGASYNC_IDLE ||\n\t\t\t\t    !(ftsInfo->poll_revents & POLLOUT))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ftsInfo->state == FTS_PROBE_SEGMENT)\n\t\t\t\t\tmessage_type = FTS_MSG_PROBE;\n\t\t\t\telse if (ftsInfo->state == FTS_SYNCREP_OFF_SEGMENT)\n\t\t\t\t\tmessage_type = FTS_MSG_SYNCREP_OFF;\n\t\t\t\telse\n\t\t\t\t\tmessage_type = FTS_MSG_PROMOTE;\n\n\t\t\t\tsnprintf(message, FTS_MSG_MAX_LEN, FTS_MSG_FORMAT,\n\t\t\t\t\t\t message_type,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex);\n\n\t\t\t\tif (PQsendQuery(ftsInfo->conn, message))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tftsInfo->poll_events = POLLIN;\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t   \"FTS sent %s to (content=%d, dbid=%d), retry_count=%d\",\n\t\t\t\t\t\t   message, ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid, ftsInfo->retry_count);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(LOG,\n\t\t\t\t\t\t \"FTS: failed to send %s to segment (content=%d, \"\n\t\t\t\t\t\t \"dbid=%d) state=%d, retry_count=%d, \"\n\t\t\t\t\t\t \"conn->asyncStatus=%d %s\", message,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t ftsInfo->conn->asyncStatus,\n\t\t\t\t\t\t PQerrorMessage(ftsInfo->conn));\n\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic void\nprobeRecordResponse(fts_segment_info *ftsInfo, PGresult *result)\n{\n\tftsInfo->result.isPrimaryAlive = true;\n\n\tftsInfo->result.isMirrorAlive = *PQgetvalue(result, 0,\n\t\t\tAnum_fts_message_response_is_mirror_up);\n\n\tftsInfo->result.isInSync = *PQgetvalue(result, 0,\n\t\t\tAnum_fts_message_response_is_in_sync);\n\n\tftsInfo->result.isSyncRepEnabled = *PQgetvalue(result, 0,\n\t\t\tAnum_fts_message_response_is_syncrep_enabled);\n\n\tftsInfo->result.isRoleMirror = *PQgetvalue(result, 0,\n\t\t\tAnum_fts_message_response_is_role_mirror);\n\n\tftsInfo->result.retryRequested = *PQgetvalue(result, 0,\n\t\t\tAnum_fts_message_response_request_retry);\n\n\telogif(gp_log_fts >= GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t   \"FTS: segment (content=%d, dbid=%d, role=%c) reported \"\n\t\t   \"isMirrorUp %d, isInSync %d, isSyncRepEnabled %d, \"\n\t\t   \"isRoleMirror %d, and retryRequested %d to the prober.\",\n\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t   ftsInfo->primary_cdbinfo->config->role,\n\t\t   ftsInfo->result.isMirrorAlive,\n\t\t   ftsInfo->result.isInSync,\n\t\t   ftsInfo->result.isSyncRepEnabled,\n\t\t   ftsInfo->result.isRoleMirror,\n\t\t   ftsInfo->result.retryRequested);\n}\n\n\nstatic void\nftsReceive(fts_context *context)\n{\n\tfts_segment_info *ftsInfo;\n\tPGresult *result = NULL;\n\tint ntuples;\n\tint nfields;\n\tint i;\n\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tftsInfo = &context->perSegInfos[i];\n\t\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\t   \"FTS: ftsReceive (content=%d, dbid=%d) state=%d, \"\n\t\t\t   \"retry_count=%d, conn->asyncStatus=%d\",\n\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t   ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t   ftsInfo->state, ftsInfo->retry_count,\n\t\t\t   ftsInfo->conn ? ftsInfo->conn->asyncStatus : -1);\n\t\tswitch(ftsInfo->state)\n\t\t{\n\t\t\tcase FTS_PROBE_SEGMENT:\n\t\t\tcase FTS_SYNCREP_OFF_SEGMENT:\n\t\t\tcase FTS_PROMOTE_SEGMENT:\n\t\t\t\t\n\t\t\t\tif (PQstatus(ftsInfo->conn) != CONNECTION_OK ||\n\t\t\t\t\t!(ftsInfo->poll_revents & POLLIN))\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tif (!PQconsumeInput(ftsInfo->conn))\n\t\t\t\t{\n\t\t\t\t\telog(LOG, \"FTS: failed to read from (content=%d, dbid=%d)\"\n\t\t\t\t\t\t \" state=%d, retry_count=%d, conn->asyncStatus=%d %s\",\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t ftsInfo->conn->asyncStatus,\n\t\t\t\t\t\t PQerrorMessage(ftsInfo->conn));\n\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (PQisBusy(ftsInfo->conn))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tresult = PQgetResult(ftsInfo->conn);\n\n\t\t\t\tif (!result || PQstatus(ftsInfo->conn) == CONNECTION_BAD)\n\t\t\t\t{\n\t\t\t\t\telog(LOG, \"FTS: error getting results from (content=%d, \"\n\t\t\t\t\t\t \"dbid=%d) state=%d, retry_count=%d, \"\n\t\t\t\t\t\t \"conn->asyncStatus=%d conn->status=%d %s\",\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t ftsInfo->conn->asyncStatus,\n\t\t\t\t\t\t ftsInfo->conn->status,\n\t\t\t\t\t\t PQerrorMessage(ftsInfo->conn));\n\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (PQresultStatus(result) != PGRES_TUPLES_OK)\n\t\t\t\t{\n\t\t\t\t\telog(LOG, \"FTS: error response from (content=%d, dbid=%d)\"\n\t\t\t\t\t\t \" state=%d, retry_count=%d, conn->asyncStatus=%d %s\",\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t ftsInfo->conn->asyncStatus,\n\t\t\t\t\t\t PQresultErrorMessage(result));\n\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tntuples = PQntuples(result);\n\t\t\t\tnfields = PQnfields(result);\n\t\t\t\tif (nfields != Natts_fts_message_response ||\n\t\t\t\t\tntuples != FTS_MESSAGE_RESPONSE_NTUPLES)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\telog(LOG, \"FTS: invalid response from (content=%d, dbid=%d)\"\n\t\t\t\t\t\t \" state=%d, retry_count=%d, expected %d tuple with \"\n\t\t\t\t\t\t \"%d fields, got %d tuples with %d fields\",\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t\t ftsInfo->primary_cdbinfo->config->dbid,\n\t\t\t\t\t\t ftsInfo->state, ftsInfo->retry_count,\n\t\t\t\t\t\t FTS_MESSAGE_RESPONSE_NTUPLES,\n\t\t\t\t\t\t Natts_fts_message_response, ntuples, nfields);\n\t\t\t\t\tftsInfo->state = nextFailedState(ftsInfo->state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprobeRecordResponse(ftsInfo, result);\n\t\t\t\tftsInfo->state = nextSuccessState(ftsInfo->state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (result && result != ftsInfo->conn->result)\n\t\t{\n\t\t\tPQclear(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n}\n\nstatic void\nretryForFtsFailed(fts_segment_info *ftsInfo, pg_time_t now)\n{\n\tif (ftsInfo->retry_count == gp_fts_probe_retries)\n\t{\n\t\telog(LOG, \"FTS max (%d) retries exhausted \"\n\t\t\t\"(content=%d, dbid=%d) state=%d\",\n\t\t\tftsInfo->retry_count,\n\t\t\tftsInfo->primary_cdbinfo->config->segindex,\n\t\t\tftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state);\n\t\treturn;\n\t}\n\n\tftsInfo->retry_count++;\n\tif (ftsInfo->state == FTS_PROBE_SUCCESS ||\n\t\tftsInfo->state == FTS_PROBE_FAILED)\n\t\tftsInfo->state = FTS_PROBE_RETRY_WAIT;\n\telse if (ftsInfo->state == FTS_SYNCREP_OFF_FAILED)\n\t\tftsInfo->state = FTS_SYNCREP_OFF_RETRY_WAIT;\n\telse\n\t\tftsInfo->state = FTS_PROMOTE_RETRY_WAIT;\n\tftsInfo->retryStartTime = now;\n\telogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,\n\t\t\"FTS initialized retry start time to now \"\n\t\t\"(content=%d, dbid=%d) state=%d\",\n\t\tftsInfo->primary_cdbinfo->config->segindex,\n\t\tftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state);\n\n\tPQfinish(ftsInfo->conn);\n\tftsInfo->conn = NULL;\n\tftsInfo->poll_events = ftsInfo->poll_revents = 0;\n\t\n\tmemset(&ftsInfo->result, 0, sizeof(fts_result));\n}\n\n\nstatic void\nprocessRetry(fts_context *context)\n{\n\tfts_segment_info *ftsInfo;\n\tint i;\n\tpg_time_t now = (pg_time_t) time(NULL);\n\n\tfor (i = 0; i < context->num_pairs; i++)\n\t{\n\t\tftsInfo = &context->perSegInfos[i];\n\t\tswitch(ftsInfo->state)\n\t\t{\n\t\t\tcase FTS_PROBE_SUCCESS:\n\t\t\t\t\n\t\t\t\tif (!(ftsInfo->result.retryRequested && context->has_mirrors &&\n\t\t\t\t\t  SEGMENT_IS_ALIVE(ftsInfo->mirror_cdbinfo)))\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase FTS_PROBE_FAILED:\n\t\t\tcase FTS_SYNCREP_OFF_FAILED:\n\t\t\tcase FTS_PROMOTE_FAILED:\n\t\t\t\tretryForFtsFailed(ftsInfo, now);\n\t\t\t\tbreak;\n\t\t\tcase FTS_PROBE_RETRY_WAIT:\n\t\t\tcase FTS_SYNCREP_OFF_RETRY_WAIT:\n\t\t\tcase FTS_PROMOTE_RETRY_WAIT:\n\t\t\t\t\n\t\t\t\tif ((int) (now - ftsInfo->retryStartTime) < 1)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t   \"FTS retrying attempt %d (content=%d, dbid=%d) \"\n\t\t\t\t\t   \"state=%d\", ftsInfo->retry_count,\n\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->segindex,\n\t\t\t\t\t   ftsInfo->primary_cdbinfo->config->dbid, ftsInfo->state);\n\t\t\t\tif (ftsInfo->state == FTS_PROBE_RETRY_WAIT)\n\t\t\t\t\tftsInfo->state = FTS_PROBE_SEGMENT;\n\t\t\t\telse if (ftsInfo->state == FTS_SYNCREP_OFF_RETRY_WAIT)\n\t\t\t\t\tftsInfo->state = FTS_SYNCREP_OFF_SEGMENT;\n\t\t\t\telse\n\t\t\t\t\tftsInfo->state = FTS_PROMOTE_SEGMENT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic bool\nftsResponseReady(fts_segment_info *ftsInfo)\n{\n\treturn (IsFtsMessageStateSuccess(ftsInfo->state) ||\n\t\t\tIsFtsMessageStateFailed(ftsInfo->state));\n}\n\nstatic bool\nupdateConfiguration(CdbComponentDatabaseInfo *primary,\n\t\t\t\t\tCdbComponentDatabaseInfo *mirror,\n\t\t\t\t\tchar newPrimaryRole, char newMirrorRole,\n\t\t\t\t\tbool IsInSync, bool IsPrimaryAlive, bool IsMirrorAlive)\n{\n\tbool UpdatePrimary = (IsPrimaryAlive != SEGMENT_IS_ALIVE(primary));\n\tbool UpdateMirror = (IsMirrorAlive != SEGMENT_IS_ALIVE(mirror));\n\n\t\n\tif (IsInSync != SEGMENT_IS_IN_SYNC(primary))\n\t\tUpdatePrimary = UpdateMirror = true;\n\n\t\n\tAssertImply(newPrimaryRole == GP_SEGMENT_CONFIGURATION_ROLE_MIRROR,\n\t\t\t\tSEGMENT_IS_IN_SYNC(mirror) && !IsInSync && !IsPrimaryAlive);\n\n\t\n\tAssert(primary->config->mode == mirror->config->mode);\n\n\tbool UpdateNeeded = UpdatePrimary || UpdateMirror;\n\t\n\tResourceOwner save = CurrentResourceOwner;\n\tif (UpdateNeeded)\n\t{\n\t\tStartTransactionCommand();\n\t\tGetTransactionSnapshot();\n\n\t\tif (UpdatePrimary)\n\t\t\tprobeWalRepUpdateConfig(primary->config->dbid, primary->config->segindex,\n\t\t\t\t\t\t\t\t\tnewPrimaryRole, IsPrimaryAlive,\n\t\t\t\t\t\t\t\t\tIsInSync);\n\n\t\tif (UpdateMirror)\n\t\t\tprobeWalRepUpdateConfig(mirror->config->dbid, mirror->config->segindex,\n\t\t\t\t\t\t\t\t\tnewMirrorRole, IsMirrorAlive,\n\t\t\t\t\t\t\t\t\tIsInSync);\n\n\t\tCommitTransactionCommand();\n\t\tCurrentResourceOwner = save;\n\n\t\t\n\t\tAssert(ftsProbeInfo);\n\t\tif (IsPrimaryAlive)\n\t\t\tFTS_STATUS_SET_UP(ftsProbeInfo->status[primary->config->dbid]);\n\t\telse\n\t\t\tFTS_STATUS_SET_DOWN(ftsProbeInfo->status[primary->config->dbid]);\n\n\t\tif (IsMirrorAlive)\n\t\t\tFTS_STATUS_SET_UP(ftsProbeInfo->status[mirror->config->dbid]);\n\t\telse\n\t\t\tFTS_STATUS_SET_DOWN(ftsProbeInfo->status[mirror->config->dbid]);\n\t}\n\n\treturn UpdateNeeded;\n}\n\n\nstatic void\nupdateSegmentDownStatus(CdbComponentDatabaseInfo *primary,\n\t\t\t\t\t\tbool isSegmentAlive,\n\t\t\t\t\t\tbool hasMirrors)\n{\n\t\n\tif (isSegmentAlive && !bms_is_member(primary->config->segindex, failedContentIds))\n\t\treturn;\n\t\n\tif (!isSegmentAlive && bms_is_member(primary->config->segindex, failedContentIds))\n\t\treturn;\n\t\n\tStartTransactionCommand();\n\tGetTransactionSnapshot();\n\tprobeUpdateConfHistory(primary, isSegmentAlive, hasMirrors);\n\n\tCommitTransactionCommand();\n\tif (isSegmentAlive)\n\t\tfailedContentIds = bms_del_member(failedContentIds, primary->config->segindex);\n\telse\n\t\tfailedContentIds = bms_add_member(failedContentIds, primary->config->segindex);\n}\n\n\nstatic bool\nprocessResponse(fts_context *context)\n{\n\tbool is_updated = false;\n\n\tfor (int response_index = 0;\n\t\t response_index < context->num_pairs && FtsIsActive();\n\t\t response_index ++)\n\t{\n\t\tfts_segment_info *ftsInfo = &(context->perSegInfos[response_index]);\n\n\t\t\n\t\tif (!ftsResponseReady(ftsInfo))\n\t\t\tcontinue;\n\n\t\t\n\t\tAssertImply(IsFtsMessageStateFailed(ftsInfo->state),\n\t\t\t\t\tftsInfo->retry_count == gp_fts_probe_retries);\n\n\t\tCdbComponentDatabaseInfo *primary = ftsInfo->primary_cdbinfo;\n\n\t\tCdbComponentDatabaseInfo *mirror = ftsInfo->mirror_cdbinfo;\n\n\t\tbool IsPrimaryAlive = ftsInfo->result.isPrimaryAlive;\n\t\t\n\t\tbool IsMirrorAlive =  IsPrimaryAlive ?\n\t\t\tftsInfo->result.isMirrorAlive : (context->has_mirrors && SEGMENT_IS_ALIVE(mirror));\n\t\tbool IsInSync = IsPrimaryAlive ?\n\t\t\tftsInfo->result.isInSync : false;\n\n\t\t\n\t\tAssertImply(IsInSync, IsPrimaryAlive && IsMirrorAlive);\n\n\t\tswitch(ftsInfo->state)\n\t\t{\n\t\t\tcase FTS_PROBE_SUCCESS:\n\t\t\t\tAssert(IsPrimaryAlive);\n\n\t\t\t\tupdateSegmentDownStatus(primary,true, context->has_mirrors);\n\n\t\t\t\tif (!context->has_mirrors)\n\t\t\t\t{\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t   \"FTS skipping mirror down update for (content=%d) as mirrorless\",\n\t\t\t\t\t\t   primary->config->segindex);\n\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t}\n\t\t\t\telse if (ftsInfo->result.isSyncRepEnabled && !IsMirrorAlive)\n\t\t\t\t{\n\t\t\t\t\tif (!ftsInfo->result.retryRequested)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tis_updated |= updateConfiguration(\n\t\t\t\t\t\t\tprimary, mirror,\n\t\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_PRIMARY,\n\t\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_MIRROR,\n\t\t\t\t\t\t\tIsInSync, IsPrimaryAlive, IsMirrorAlive);\n\t\t\t\t\t\t\n\t\t\t\t\t\tAssertImply(SEGMENT_IS_ALIVE(mirror), is_updated);\n\t\t\t\t\t\t\n\t\t\t\t\t\tftsInfo->state = FTS_SYNCREP_OFF_SEGMENT;\n\t\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t\t   \"FTS turning syncrep off on (content=%d, dbid=%d)\",\n\t\t\t\t\t\t\t   primary->config->segindex, primary->config->dbid);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t\t   \"FTS skipping mirror down update for (content=%d) as retryRequested\",\n\t\t\t\t\t\t\t   primary->config->segindex);\n\t\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ftsInfo->result.isRoleMirror)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tAssert(!IsMirrorAlive);\n\t\t\t\t\tAssert(!SEGMENT_IS_ALIVE(mirror));\n\t\t\t\t\tAssert(SEGMENT_IS_NOT_INSYNC(mirror));\n\t\t\t\t\tAssert(SEGMENT_IS_NOT_INSYNC(primary));\n\t\t\t\t\tAssert(!ftsInfo->result.isSyncRepEnabled);\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t   \"FTS resending promote request to (content=%d,\"\n\t\t\t\t\t\t   \" dbid=%d)\", primary->config->segindex, primary->config->dbid);\n\t\t\t\t\tftsInfo->state = FTS_PROMOTE_SEGMENT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tis_updated |= updateConfiguration(\n\t\t\t\t\t\tprimary, mirror,\n\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_PRIMARY,\n\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_MIRROR,\n\t\t\t\t\t\tIsInSync, IsPrimaryAlive, IsMirrorAlive);\n\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FTS_PROBE_FAILED:\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\tif (ftsInfo->restart_state == PM_IN_RESETTING)\n\t\t\t\t{\n\t\t\t\t\tAssert(strstr(PQerrorMessage(ftsInfo->conn), _(POSTMASTER_IN_RESET_MSG)));\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t \"FTS: detected segment is in resetting mode \"\n\t\t\t\t\t\t \"(content=%d) primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t\t\t primary->config->segindex, primary->config->dbid, mirror->config->dbid);\n\n\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ftsInfo->restart_state == PM_IN_RECOVERY_MAKING_PROGRESS)\n\t\t\t\t{\n\t\t\t\t\tAssert(strstr(PQerrorMessage(ftsInfo->conn), _(POSTMASTER_IN_RECOVERY_MSG)) ||\n\t\t\t\t\t\t   strstr(PQerrorMessage(ftsInfo->conn), _(POSTMASTER_IN_STARTUP_MSG)));\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t \"FTS: detected segment is in recovery mode and making \"\n\t\t\t\t\t\t \"progress (content=%d) primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t\t\t primary->config->segindex, primary->config->dbid, mirror->config->dbid);\n\n\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tAssert(!IsPrimaryAlive);\n\t\t\t\t\n\t\t\t\tif (context->has_mirrors && SEGMENT_IS_IN_SYNC(mirror))\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tAssert(SEGMENT_IS_IN_SYNC(primary));\n\n\t\t\t\t\t\n\t\t\t\t\tis_updated |= updateConfiguration(\n\t\t\t\t\t\tprimary, mirror,\n\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_MIRROR, \n\t\t\t\t\t\tGP_SEGMENT_CONFIGURATION_ROLE_PRIMARY, \n\t\t\t\t\t\tIsInSync, IsPrimaryAlive, IsMirrorAlive);\n\t\t\t\t\tAssert(is_updated);\n\n\t\t\t\t\t\n\t\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t\t   \"FTS promoting mirror (content=%d, dbid=%d) \"\n\t\t\t\t\t\t   \"to be the new primary\",\n\t\t\t\t\t\t   mirror->config->segindex, mirror->config->dbid);\n\t\t\t\t\tftsInfo->state = FTS_PROMOTE_SEGMENT;\n\t\t\t\t\tftsInfo->primary_cdbinfo = mirror;\n\t\t\t\t\tftsInfo->mirror_cdbinfo = primary;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif (context->has_mirrors)\n\t\t\t\t\t{\n\t\t\t\t\t\telog(WARNING, \"ERROR: FTS double fault detected (content=%d) \"\n\t\t\t\t\t\t\t\t  \"primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t\t\t\t\t  primary->config->segindex, primary->config->dbid, mirror->config->dbid);\n\t\t\t\t\t }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\telog(WARNING, \"ERROR: FTS detected segment down (content=%d) \"\n\t\t\t\t\t\t\t\t\t  \"primary dbid=%d\",\n\t\t\t\t\t\t\t primary->config->segindex, primary->config->dbid);\n\t\t\t\t\t}\n\t\t\t\t\tupdateSegmentDownStatus(primary,false, context->has_mirrors);\n\t\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FTS_SYNCREP_OFF_FAILED:\n\t\t\t\t\n\t\t\t\telog(WARNING, \"FTS failed to turn off syncrep on (content=%d,\"\n\t\t\t\t\t \" dbid=%d)\", primary->config->segindex, primary->config->dbid);\n\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\tbreak;\n\t\t\tcase FTS_PROMOTE_FAILED:\n\t\t\t\t\n\t\t\t\telog(WARNING, \"ERROR: FTS double fault detected (content=%d) \"\n\t\t\t\t\t \"primary dbid=%d, mirror dbid=%d\",\n\t\t\t\t\t primary->config->segindex, primary->config->dbid, mirror->config->dbid);\n\t\t\t\tupdateSegmentDownStatus(primary,false, context->has_mirrors);\n\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\tbreak;\n\t\t\tcase FTS_PROMOTE_SUCCESS:\n\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t   \"FTS mirror (content=%d, dbid=%d) promotion \"\n\t\t\t\t\t   \"triggered successfully\",\n\t\t\t\t\t   primary->config->segindex, primary->config->dbid);\n\t\t\t\tupdateSegmentDownStatus(primary,true, context->has_mirrors);\n\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\tbreak;\n\t\t\tcase FTS_SYNCREP_OFF_SUCCESS:\n\t\t\t\telogif(gp_log_fts >= GPVARS_VERBOSITY_VERBOSE, LOG,\n\t\t\t\t\t   \"FTS primary (content=%d, dbid=%d) notified to turn \"\n\t\t\t\t\t   \"syncrep off\", primary->config->segindex, primary->config->dbid);\n\t\t\t\tftsInfo->state = FTS_RESPONSE_PROCESSED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"FTS invalid internal state %d for (content=%d) \"\n\t\t\t\t\t\t\t\"primary dbid=%d, mirror dbid=%d\", ftsInfo->state,\n\t\t\t\t\t primary->config->segindex, primary->config->dbid,\n\t\t\t\t\t context->has_mirrors  ? mirror->config->dbid : -1);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tmemset(&ftsInfo->result, 0, sizeof(fts_result));\n\t\tPQfinish(ftsInfo->conn);\n\t\tftsInfo->conn = NULL;\n\t\tftsInfo->poll_events = ftsInfo->poll_revents = 0;\n\t\tftsInfo->retry_count = 0;\n\t\tftsInfo->timeout_count = 0;\n\t}\n\n\treturn is_updated;\n}\n\n\nstatic bool\nFtsIsSegmentAlive(CdbComponentDatabaseInfo *segInfo)\n{\n\tif (SEGMENT_IS_ACTIVE_MIRROR(segInfo) && SEGMENT_IS_ALIVE(segInfo))\n\t\treturn true;\n\n\tif (SEGMENT_IS_ACTIVE_PRIMARY(segInfo))\n\t\treturn true;\n\n\treturn false;\n}\n\n\n\nstatic void\nFtsWalRepInitProbeContext(CdbComponentDatabases *cdbs, fts_context *context)\n{\n\tcontext->num_pairs = cdbs->total_segments;\n\tcontext->perSegInfos = (fts_segment_info *) palloc0(\n\t\tcontext->num_pairs * sizeof(fts_segment_info));\n\tcontext->has_mirrors = !(cdbs->total_segment_dbs == cdbs->total_segments);\n\n\tint fts_index = 0;\n\tint cdb_index = 0;\n\tCdbComponentDatabaseInfo *mirror = NULL;\n\n\tfor(; cdb_index < cdbs->total_segment_dbs; cdb_index++)\n\t{\n\t\tCdbComponentDatabaseInfo *primary = &(cdbs->segment_db_info[cdb_index]);\n\t\tif (!SEGMENT_IS_ACTIVE_PRIMARY(primary))\n\t\t\tcontinue;\n\t\tmirror = FtsGetPeerSegment(cdbs,\n\t\t\t\t\t\t\t\t   primary->config->segindex,\n\t\t\t\t\t\t\t\t   primary->config->dbid);\n\t\tif (context->has_mirrors && !mirror)\n\t\t{\n\t\t\t\n\t\t\tcontext->num_pairs--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tAssert(FtsIsSegmentAlive(primary));\n\n\t\tfts_segment_info *ftsInfo = &(context->perSegInfos[fts_index]);\n\t\t\n\t\tftsInfo->result.isPrimaryAlive = false;\n\t\tftsInfo->result.isMirrorAlive = false;\n\t\tftsInfo->result.isInSync = false;\n\t\tftsInfo->result.isSyncRepEnabled = false;\n\t\tftsInfo->result.retryRequested = false;\n\t\tftsInfo->result.isRoleMirror = false;\n\t\tftsInfo->result.dbid = primary->config->dbid;\n\t\tftsInfo->state = FTS_PROBE_SEGMENT;\n\t\tftsInfo->restart_state = PM_NOT_IN_RESTART;\n\t\tftsInfo->xlogrecptr = InvalidXLogRecPtr;\n\n\t\tftsInfo->primary_cdbinfo = primary;\n\t\tftsInfo->mirror_cdbinfo = mirror;\n\n\t\tAssert(fts_index < context->num_pairs);\n\t\tfts_index ++;\n\t}\n}\n\nstatic void\nInitPollFds(size_t size)\n{\n\tPollFds = (struct pollfd *) palloc0(size * sizeof(struct pollfd));\n}\n\nbool\nFtsWalRepMessageSegments(CdbComponentDatabases *cdbs)\n{\n\tbool is_updated = false;\n\tfts_context context;\n\n\tFtsWalRepInitProbeContext(cdbs, &context);\n\tInitPollFds(cdbs->total_segments);\n\n\twhile (!allDone(&context) && FtsIsActive())\n\t{\n\t\tftsConnect(&context);\n\t\tftsPoll(&context);\n\t\tftsSend(&context);\n\t\tftsReceive(&context);\n\t\tprocessRetry(&context);\n\t\tis_updated |= processResponse(&context);\n\t}\n\tint i;\n\tif (!FtsIsActive())\n\t{\n\t\tfor (i = 0; i < context.num_pairs; i++)\n\t\t{\n\t\t\tif (context.perSegInfos[i].conn)\n\t\t\t{\n\t\t\t\tPQfinish(context.perSegInfos[i].conn);\n\t\t\t\tcontext.perSegInfos[i].conn = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < context.num_pairs; i++)\n\t{\n\t\tif (context.perSegInfos[i].conn != NULL)\n\t\t\telog(ERROR,\n\t\t\t\t \"FTS libpq connection left open (content=%d, dbid=%d)\"\n\t\t\t\t \" state=%d, retry_count=%d, conn->status=%d\",\n\t\t\t\t context.perSegInfos[i].primary_cdbinfo->config->segindex,\n\t\t\t\t context.perSegInfos[i].primary_cdbinfo->config->dbid,\n\t\t\t\t context.perSegInfos[i].state,\n\t\t\t\t context.perSegInfos[i].retry_count,\n\t\t\t\t context.perSegInfos[i].conn->status);\n\t}\n\n\tpfree(context.perSegInfos);\n\tpfree(PollFds);\n\treturn is_updated;\n}\n\n\n",
        "severity_level": null,
        "errmsg_template": null,
        "errmsg_variables": null,
        "errcode": null,
        "errcode_numeric": null,
        "errmsg_clean": null,
        "script_parse_error": "Failed to parse elog log",
        "file_path": "src/backend/fts/ftsprobe.c:197"
    }
]